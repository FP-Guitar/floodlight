From 86474f33b3404626f6bd303d12251239198b83a8 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Fri, 30 Nov 2018 10:20:23 +0100
Subject: [PATCH 01/18] Update README.md

Add disclaimer for foreigners ;)
---
 README.md | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/README.md b/README.md
index b32912a8..5920a14f 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,6 @@
+FORK FOR A UNIVERSITY PROJECT, DO NOT EXPECT TO FIND ANYTHING USEFUL HERE ;)
+============================================================================
+
 Floodlight OpenFlow Controller (OSS)
 ====================================
 
-- 
2.17.1


From aa6bfd75280f80b2823f5abbb2e22e4007ffeb26 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Fri, 30 Nov 2018 11:48:14 +0100
Subject: [PATCH 02/18] [ADD TASK32] Add sources for Task32

---
 src/main/java/net/sdnlab/common/Helper.java   |   6 +
 .../java/net/sdnlab/ex2/PacketRouter.java     | 104 ++++++++++++++++++
 src/main/java/net/sdnlab/ex2/Task23.java      |  74 +++++++++++++
 .../java/net/sdnlab/ex2/Task23Worker.java     | 103 +++++++++++++++++
 .../ex2/Task23WorkerInstallBlueFlow.java      |  56 ++++++++++
 .../Task23WorkerStartControllerRouting.java   |  96 ++++++++++++++++
 .../net/sdnlab/ex2/Task23WorkerState.java     |  79 +++++++++++++
 .../net/sdnlab/ex2/Task23WorkerStateInit.java |  46 ++++++++
 .../Task23WorkerStatePushInitialFlows.java    |  30 +++++
 ...k23WorkerStateRemoveControllerRouting.java |  38 +++++++
 src/main/java/net/sdnlab/task31/ARPCache.java |  15 +++
 src/main/java/net/sdnlab/task31/ARPEntry.java |  23 ++++
 12 files changed, 670 insertions(+)
 create mode 100644 src/main/java/net/sdnlab/common/Helper.java
 create mode 100644 src/main/java/net/sdnlab/ex2/PacketRouter.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23Worker.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerInstallBlueFlow.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerStartControllerRouting.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerState.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerStateInit.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerStatePushInitialFlows.java
 create mode 100644 src/main/java/net/sdnlab/ex2/Task23WorkerStateRemoveControllerRouting.java
 create mode 100644 src/main/java/net/sdnlab/task31/ARPCache.java
 create mode 100644 src/main/java/net/sdnlab/task31/ARPEntry.java

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
new file mode 100644
index 00000000..5ff8f2ea
--- /dev/null
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -0,0 +1,6 @@
+package net.sdnlab.common;
+/**
+ * Class used for common Function based calls...
+ * @author fabian
+ *
+ */
diff --git a/src/main/java/net/sdnlab/ex2/PacketRouter.java b/src/main/java/net/sdnlab/ex2/PacketRouter.java
new file mode 100644
index 00000000..ba8b5ada
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/PacketRouter.java
@@ -0,0 +1,104 @@
+package net.sdnlab.ex2;
+
+import java.util.Collections;
+import java.util.List;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFMessage;
+import org.projectfloodlight.openflow.protocol.OFPacketOut;
+import org.projectfloodlight.openflow.protocol.OFType;
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.OFPort;
+
+import net.floodlightcontroller.core.FloodlightContext;
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.IOFMessageListener;
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.packet.Ethernet;
+import net.floodlightcontroller.packet.IPv4;
+
+/**
+ * Perform controller based routing to 10.0.0.2
+ * only little changes needed to make this generic...
+ * @author fabian
+ *
+ */
+public class PacketRouter implements IOFMessageListener {
+	IFloodlightProviderService floodlightProvider;
+	IOFSwitch  switch1;
+	IOFSwitch  switch2;
+	OFFactory switch2Factory;
+	
+	IPv4Address destinationIP = IPv4Address.of("10.0.0.2");
+	/**
+	 * Construct a PacketRouter which routes packets from switch1 to switch2
+	 * if they match the hardcoded destinationIP.
+	 * @param floodlightProvider IFloodlightProviderService implementation
+	 * @param switch1 The switch where to expect packets
+	 * @param switch2 The switch where to put the packets
+	 */
+	PacketRouter( IFloodlightProviderService floodlightProvider, IOFSwitch switch1, IOFSwitch switch2 ) {
+		this.floodlightProvider = floodlightProvider;
+		this.switch1 = switch1;
+		this.switch2 = switch2;
+		// unlikely this will change
+		switch2Factory = switch2.getOFFactory();
+	}
+		
+	@Override
+	public String getName() {
+		return PacketRouter.class.getName();
+	}
+
+	@Override
+	public boolean isCallbackOrderingPrereq(OFType type, String name) {
+ 		return false;
+	}
+
+	@Override
+	public boolean isCallbackOrderingPostreq(OFType type, String name) {
+		return false;
+	}
+	public void startRouting() {
+		this.floodlightProvider.addOFMessageListener(OFType.PACKET_IN, this);
+	}
+	public void stopRouting() {
+		this.floodlightProvider.removeOFMessageListener(OFType.PACKET_IN, this);
+	}
+
+	@Override
+	public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
+		// check if we are interested
+		if( sw.equals(switch1)) {
+			Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);
+			// check if we have a packet of the right type
+			if( eth.getEtherType().equals(EthType.IPv4)) {				
+				IPv4 payload = (IPv4) eth.getPayload();
+				IPv4Address destination = payload.getDestinationAddress();
+				// check if we have a packet of the right destination
+				if( destination.equals(destination)) {
+					//now we can serialize the packet again, and send it to the second switch
+					byte[] serializedPacket= eth.serialize();
+					// still ugly, but i don't care
+					List<OFAction> actions = Collections.singletonList(
+								(OFAction)switch2Factory.actions().output(OFPort.of(1), 0xffFFffFF)
+							);
+					OFPacketOut po = switch2Factory.buildPacketOut()
+							.setData(serializedPacket)
+							.setActions(actions)
+							.setInPort(OFPort.CONTROLLER)
+							.build();
+					// finally write to output
+					switch2.write(po);
+				}
+			}
+			// we handled this one, no one else should be interested (for now)
+			return Command.STOP;
+		}
+		// if not interested, give other modules the chance to handle it 
+		return Command.CONTINUE;
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23.java b/src/main/java/net/sdnlab/ex2/Task23.java
new file mode 100644
index 00000000..2426c6e0
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23.java
@@ -0,0 +1,74 @@
+package net.sdnlab.ex2;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.concurrent.ScheduledExecutorService;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.core.module.FloodlightModuleContext;
+import net.floodlightcontroller.core.module.FloodlightModuleException;
+import net.floodlightcontroller.core.module.IFloodlightModule;
+import net.floodlightcontroller.core.module.IFloodlightService;
+import net.floodlightcontroller.threadpool.IThreadPoolService;
+
+// we don't need the  IOFMessageListener Interface here,
+// the packet routing is done by PacketRouter class.
+public class Task23 implements IFloodlightModule {
+	protected IOFSwitchService switchService;
+	protected IFloodlightProviderService floodlightProvider;
+	protected IThreadPoolService threadPoolService;
+	
+	// Task23Worker does the 'work'
+	protected Task23Worker worker;
+		
+	private static Logger logger;
+
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
+		 Collection<Class<? extends IFloodlightService>> moduleDependencies = new
+				ArrayList<Class<? extends IFloodlightService>>();
+		 moduleDependencies.add(IFloodlightProviderService.class);
+		 moduleDependencies.add(IOFSwitchService.class);
+		 moduleDependencies.add(IThreadPoolService.class);
+		return moduleDependencies;
+	}
+
+	@Override
+	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
+		// get Implementations for used modules
+		this.floodlightProvider = context.getServiceImpl(IFloodlightProviderService.class);
+		this.switchService = context.getServiceImpl(IOFSwitchService.class);
+		this.threadPoolService = context.getServiceImpl(IThreadPoolService.class);
+		// get logger
+		logger = LoggerFactory.getLogger(Task23.class);
+	}
+
+	@Override
+	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		logger.info("Startup...." );
+		ScheduledExecutorService ses = threadPoolService.getScheduledExecutor();
+		// The Workerthread does the work for this task
+		// it waits until all switches are known, then pushes the initial flows
+		// waits again some time and performs the two phased update
+        worker = new Task23Worker( switchService, floodlightProvider, ses);
+	}
+
+
+
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23Worker.java b/src/main/java/net/sdnlab/ex2/Task23Worker.java
new file mode 100644
index 00000000..632f49e7
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23Worker.java
@@ -0,0 +1,103 @@
+package net.sdnlab.ex2;
+
+import java.util.HashMap;
+import java.util.concurrent.ScheduledExecutorService;
+
+
+import org.projectfloodlight.openflow.types.U64;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.core.util.SingletonTask;
+
+/**
+ * A Task23Worker is  responsible for the
+ * correct execution of the tasks given in the
+ * Task23 Problem Description. It is an implementation
+ * of the state pattern. This pattern was chosen to reflect
+ * the different phases, which can be identified:
+ *
+ * StateInit:
+ * 	We have to wait until the controller knows all switches
+ *    
+ * ::-->StatePushInitialFlows:
+ *  Here we install the blue flow, then wait for some time until
+ * 
+ * ::-->StartControllerRouting:
+ *  We install the routing over the controller
+ * 
+ * ::-->InstallRedFLow:
+ *  Install RedFlow, delete BlueFlow
+ *  
+ * ::-->RemoveControllerRouting
+ *   Give traffice back to the network
+ * 
+ * ::--> END  
+ * @author fabian
+ *
+ */
+public class Task23Worker implements Runnable {
+	// State which represents different phases of the task
+	Task23WorkerState state;
+	// Services needed for function
+	protected IOFSwitchService switchService;
+	protected IFloodlightProviderService floodlightProvider;
+	
+	// We allow states to reschedule execution of the next task
+	// ==> we need a reference to the SingletonTask responsible for us
+	// Some states may not reschedule execution and have
+	// different semantics for state change (e.g. WaitForBlueTimeout will
+	// change state, when all timeouts are received....)
+	// A SingletonTask is a task which makes sure, that even on rescheduling
+	// using the ExecutorService, only one instance is running at the same time.
+	protected SingletonTask ownTask;
+	
+	// we use a simple name --> switch map for easier access
+	// we will store all switches of the topology here
+	protected HashMap<String, IOFSwitch> switches = new HashMap<String, IOFSwitch>();
+	
+	// These cookies identify red and blue flow,
+	// this makes deleting the flows very easy
+	static final U64 BLUE_FLOW = U64.of(0x01);
+	static final U64 RED_FLOW = U64.of(0x02);
+	// Wanted to play around with priorities
+	protected int bluePriority= 1000;
+	protected int redPriority = 900;
+
+	// we use this one for routing over the controller
+	protected PacketRouter packetRouter;
+	// identify the packet in also by a nice cookie
+	static final U64 CONTROLLER_ROUTING = U64.of(0x04);
+	
+	protected static Logger logger;
+	
+	public Task23Worker(IOFSwitchService switchService, IFloodlightProviderService floodlightProvider, ScheduledExecutorService executorService) {
+		this.switchService = switchService;
+		this.floodlightProvider = floodlightProvider;
+		
+		// well we want to have some logging...
+		logger= LoggerFactory.getLogger(Task23.class);
+		
+		// initate the state machine
+		this.state = new Task23WorkerStateInit();
+		this.ownTask = new SingletonTask(executorService, this);
+		run();
+	}
+
+	@Override
+	public void run() {
+		logger.info("Processing state: {}", state.getClass().getSimpleName());
+		state.processState(this);
+
+	}
+
+	protected void changeState(Task23WorkerState state) {
+		this.state = state;
+	}
+	
+	
+
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerInstallBlueFlow.java b/src/main/java/net/sdnlab/ex2/Task23WorkerInstallBlueFlow.java
new file mode 100644
index 00000000..11ff063a
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerInstallBlueFlow.java
@@ -0,0 +1,56 @@
+package net.sdnlab.ex2;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowDelete;
+
+
+import net.floodlightcontroller.core.IOFSwitch;
+
+
+/**
+ * Remove red flow completely, install the blue flow
+ * @author fabian
+ *
+ */
+public class Task23WorkerInstallBlueFlow extends Task23WorkerState {
+
+	@Override
+	public void processState(Task23Worker context) {
+		deleteRedFlow(context);
+		addBlueFlow(context);
+		
+		// our next action should be the removal of controller routing
+		changeState(context, new Task23WorkerStateRemoveControllerRouting());
+		context.run();
+	}
+
+	private void addBlueFlow(Task23Worker context) {
+		// once again, 'data', prior knowledge, hard coded
+		updateSwitch("S1", 2, Task23Worker.BLUE_FLOW,  context.bluePriority, context);
+		updateSwitch("S2", 2, Task23Worker.BLUE_FLOW,  context.bluePriority, context);
+		updateSwitch("S4", 3, Task23Worker.BLUE_FLOW,  context.bluePriority, context);
+		updateSwitch("S6", 3, Task23Worker.BLUE_FLOW,  context.bluePriority, context);
+		updateSwitch("S8", 1, Task23Worker.BLUE_FLOW,  context.bluePriority, context);
+	}
+
+	
+	private void deleteRedFlow(Task23Worker context) {
+		// Go through all known switches and delete
+		// flows witch belong to the red flow
+		for( String switchName : context.switches.keySet() )
+		{
+			Task23Worker.logger.info("Deleting red flow on switch " + switchName);
+			IOFSwitch sw = context.switches.get(switchName);
+			OFFactory factoryToUse = sw.getOFFactory();
+		
+			OFFlowDelete flowDelete = factoryToUse.buildFlowDelete()				
+					.setCookie(Task23Worker.RED_FLOW)
+					.setCookieMask(Task23Worker.RED_FLOW)
+					.build();
+			
+			// check if it was  successfully written to the switch
+			boolean wasSuccess = sw.write(flowDelete);
+			Task23Worker.logger.info("Success: " +  wasSuccess);
+		}
+	}
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerStartControllerRouting.java b/src/main/java/net/sdnlab/ex2/Task23WorkerStartControllerRouting.java
new file mode 100644
index 00000000..52992d59
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerStartControllerRouting.java
@@ -0,0 +1,96 @@
+package net.sdnlab.ex2;
+
+import java.util.ArrayList;
+import java.util.concurrent.TimeUnit;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowAdd;
+
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.protocol.action.OFActions;
+import org.projectfloodlight.openflow.protocol.match.Match;
+import org.projectfloodlight.openflow.protocol.match.MatchField;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.OFPort;
+
+
+import net.floodlightcontroller.core.IOFSwitch;
+
+/**
+ * This state initiates the 'Routing over the Controller' for packets
+ * from h1 two h2. Unfortunately we cannot alter the ildeTime(soft timeout) value
+ * of a flow using the OFFlowMod message, to increase probability that there are
+ * no packets still in the net, we wait some time until we go to the next phase, which
+ * installs the red flow and removes the blue flow.
+ * @author fabian
+ *
+ */
+public class Task23WorkerStartControllerRouting extends Task23WorkerState {
+
+	@Override
+	public void processState(Task23Worker context) {
+		addRoutingOverController( context );
+					
+		// give packets in the network some time to reach their destination
+		// unlikely that there are some, because we have low traffic and fast net
+		// in reality, i think buffers will be still filled to some extend.
+		// i really would like to know a better approach to handle this...
+		changeState(context, new Task23WorkerInstallBlueFlow());	
+		context.ownTask.reschedule(500, TimeUnit.MILLISECONDS);
+	}
+	
+	private void addRoutingOverController(Task23Worker context) {
+		Task23Worker.logger.info("Create packet router for controller routing");
+		
+		// Create the PacketRouter, which actually does the ControllerSide Router Logic
+		context.packetRouter = new PacketRouter(context.floodlightProvider, context.switches.get("S1"),context.switches.get("S8"));
+		context.packetRouter.startRouting();
+		
+		// Create correspondingFLowTable on S1
+		installPacketInToControllerOnS1(context);	
+	}
+
+	
+	private void installPacketInToControllerOnS1(Task23Worker context ) {
+		Task23Worker.logger.info("Installing PACKET_IN to CONTROLLER on S1");
+		// this one should go with highest priority
+		// as it should be selected instead of the blue flow
+		int flowPriority = 32767;
+		IOFSwitch switchToUpdate = context.switches.get("S1");
+		
+		// we want to use a factory, definitely matching to the switch
+		// so instead of using generic factory with version, we 
+		// always use the factory provided by the switch
+		OFFactory factoryToUse = switchToUpdate.getOFFactory();
+		
+		// which packets to match
+		Match match = factoryToUse.buildMatch()
+				.setExact(MatchField.ETH_TYPE, EthType.IPv4)
+				.setExact(MatchField.IPV4_DST,IPv4Address.of("10.0.0.2"))
+				.build();
+		
+		
+		// create specific actions
+		ArrayList<OFAction> actionList = new ArrayList<OFAction>();
+		OFActions actions = factoryToUse.actions();
+		actionList.add(
+				actions.buildOutput()
+				.setMaxLen(0xFFffFFff)
+				.setPort(OFPort.CONTROLLER)
+				.build());
+		
+		// create the flow message
+		OFFlowAdd flowAdd = factoryToUse.buildFlowAdd()
+				.setCookie(Task23Worker.CONTROLLER_ROUTING)
+				.setPriority(flowPriority)
+				.setMatch(match)
+				.setActions(actionList)
+				.build();
+		
+		// check if it was  successfully written to the switch
+		boolean wasSuccess = switchToUpdate.write(flowAdd);
+		Task23Worker.logger.info("Success: " +  wasSuccess);
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerState.java b/src/main/java/net/sdnlab/ex2/Task23WorkerState.java
new file mode 100644
index 00000000..1908c3e6
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerState.java
@@ -0,0 +1,79 @@
+package net.sdnlab.ex2;
+
+import java.util.ArrayList;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowAdd;
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.protocol.action.OFActions;
+import org.projectfloodlight.openflow.protocol.match.Match;
+import org.projectfloodlight.openflow.protocol.match.MatchField;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.OFPort;
+import org.projectfloodlight.openflow.types.U64;
+
+import net.floodlightcontroller.core.IOFSwitch;
+
+public abstract class Task23WorkerState {
+	abstract public void processState(Task23Worker context);
+	
+	public void changeState(Task23Worker context, Task23WorkerState state) {
+		context.changeState(state);
+	}
+	
+	/**
+	 * We have very similar flows (red and blue, so we use a convenient function)
+	 * Could easily be augmented to be more generic. 
+	 * @param switchname The name of the switch
+	 * @param outputPort Where to put the packet
+	 * @param flowNumber To which flow does this update refer
+	 * @param flowpriority which priority to use
+	 * @param context context (state pattern
+	 */
+	protected void updateSwitch(String switchname, int outputPort, U64 flowNumber, int flowPriority ,Task23Worker context) {
+		Task23Worker.logger.info("Installing " +  flowToName(flowNumber)+  " on " +  switchname);
+		
+		IOFSwitch switchToUpdate = context.switches.get(switchname);
+		
+		// we want to use a factory, definitely matching to the switch
+		// so instead of using generic factory with version, we 
+		// always use the factory provided by the switch
+		OFFactory factoryToUse = switchToUpdate.getOFFactory();
+		
+		// which packets to match
+		Match match = factoryToUse.buildMatch()
+				.setExact(MatchField.ETH_TYPE, EthType.IPv4)
+				.setExact(MatchField.IPV4_DST,IPv4Address.of("10.0.0.2"))
+				.build();
+		
+		
+		// create specific actions
+		ArrayList<OFAction> actionList = new ArrayList<OFAction>();
+		OFActions actions = factoryToUse.actions();
+		actionList.add(
+				actions.buildOutput()
+				.setMaxLen(0xFFffFFff)
+				.setPort(OFPort.of(outputPort))
+				.build());
+		
+		// create the flow message
+		OFFlowAdd flowAdd = factoryToUse.buildFlowAdd()
+				.setCookie(flowNumber)
+				.setPriority(flowPriority)
+				.setMatch(match)
+				.setActions(actionList)
+				.build();
+		
+		// check if it was  successfully written to the switch
+		boolean wasSuccess = switchToUpdate.write(flowAdd);
+		Task23Worker.logger.info("Success: " +  wasSuccess);
+	}
+	
+	private String flowToName(U64 number ) {
+		if( number.equals( Task23Worker.BLUE_FLOW ) )  return "Blue Flow";
+		if( number.equals( Task23Worker.RED_FLOW ) ) return "Red Flow";		
+		return "unknown";
+		
+	}
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerStateInit.java b/src/main/java/net/sdnlab/ex2/Task23WorkerStateInit.java
new file mode 100644
index 00000000..85947632
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerStateInit.java
@@ -0,0 +1,46 @@
+package net.sdnlab.ex2;
+
+
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+/**
+ * Initial State just waits until link/topology discovery is complete,
+ * then schedules the next state
+ * @author fabian
+ *
+ */
+public class Task23WorkerStateInit extends Task23WorkerState {
+	@Override
+	public void processState(Task23Worker context) {
+		// We have to wait, until link discovery service completely found all  switches and link
+		Set<DatapathId> switchIDs = context.switchService.getAllSwitchDpids();
+		if( switchIDs.size() == 8 ) {
+			// get the needed switches;
+			// use prior knowledge, this is considered as 'data' => no generating function
+			context.switches.put("S1", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:01")) );
+			context.switches.put("S2", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:02")) );
+			context.switches.put("S3", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:03")) );
+			context.switches.put("S4", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:04")) );
+			context.switches.put("S5", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:05")) );
+			context.switches.put("S6", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:06")) );
+			context.switches.put("S7", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:07")) );
+			context.switches.put("S8", context.switchService.getSwitch(DatapathId.of("00:00:00:00:00:00:00:08")) );
+			
+			changeState(context, new Task23WorkerStatePushInitialFlows());
+			// Why is it save to run?
+			// We are running this in a SingletonTask, which means, there is only
+			// one instance of the thread running at once, so there is no concurrent situation here
+			// would be cleaner to use still two functions, but this is no code which ever will be reused.
+			context.run();
+		} else {
+			// have not found all, we wait another waitTime * unit
+			int waitTime = 1;
+			TimeUnit unit = TimeUnit.SECONDS;
+			Task23Worker.logger.info("Do not know all switches yet... try again in {} {}", waitTime, unit.toString());
+			context.ownTask.reschedule(waitTime, unit);
+		}		
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerStatePushInitialFlows.java b/src/main/java/net/sdnlab/ex2/Task23WorkerStatePushInitialFlows.java
new file mode 100644
index 00000000..6fc593d9
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerStatePushInitialFlows.java
@@ -0,0 +1,30 @@
+package net.sdnlab.ex2;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The initial flow is the red flow. When we reached this state,
+ * we know we have a complete view on the topology (all switches known).
+ * After installing the blue flow, we wait some time until we switch to the blue
+ * @author fabian
+ *
+ */
+public class Task23WorkerStatePushInitialFlows extends Task23WorkerState {
+	@Override
+	public void processState(Task23Worker context) {
+		Task23Worker.logger.info("Installing initial flows");
+		installRedFlow(context);
+		changeState(context, new Task23WorkerStartControllerRouting());
+		// we wait 20 seconds, until we change to red flow
+		context.ownTask.reschedule(20, TimeUnit.SECONDS);
+	}
+	
+	private void installRedFlow(Task23Worker context) {
+		// Hardcoded 'data' values for the red flow
+		updateSwitch("S1", 3, Task23Worker.RED_FLOW, context.redPriority, context);
+		updateSwitch("S3", 2, Task23Worker.RED_FLOW, context.redPriority, context);
+		updateSwitch("S4", 4, Task23Worker.RED_FLOW, context.redPriority, context);
+		updateSwitch("S7", 3, Task23Worker.RED_FLOW, context.redPriority, context);
+		updateSwitch("S8", 1, Task23Worker.RED_FLOW, context.redPriority, context);
+	}
+}
diff --git a/src/main/java/net/sdnlab/ex2/Task23WorkerStateRemoveControllerRouting.java b/src/main/java/net/sdnlab/ex2/Task23WorkerStateRemoveControllerRouting.java
new file mode 100644
index 00000000..576e8f72
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex2/Task23WorkerStateRemoveControllerRouting.java
@@ -0,0 +1,38 @@
+package net.sdnlab.ex2;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowDelete;
+
+
+import net.floodlightcontroller.core.IOFSwitch;
+/**
+ * Last step, now remove the 'Routing over Controller'
+ * and give traffic back to the network
+ * @author fabian
+ *
+ */
+public class Task23WorkerStateRemoveControllerRouting extends Task23WorkerState {
+
+	@Override
+	public void processState(Task23Worker context) {
+		context.packetRouter.stopRouting();
+		removePacketInToControllerOnS1(context);
+		// we are done here... so we do not trigger any further state processing or change.
+		// cleaner: add a finally "done" state...but too lazy
+	}
+	
+	private void removePacketInToControllerOnS1(Task23Worker context) {
+		Task23Worker.logger.info("Removing PACKET_IN to CONTROLLER in S1");
+		IOFSwitch sw = context.switches.get("S1");
+		OFFactory factoryToUse = sw.getOFFactory();
+		
+		OFFlowDelete flowDelete = factoryToUse.buildFlowDelete()
+				.setCookieMask(Task23Worker.CONTROLLER_ROUTING)
+				.setCookie(Task23Worker.CONTROLLER_ROUTING)
+				.build();
+		
+		// check if it was  successfully written to the switch
+		boolean wasSuccess = sw.write(flowDelete);
+		Task23Worker.logger.info("Success: " +  wasSuccess);
+	}
+}
diff --git a/src/main/java/net/sdnlab/task31/ARPCache.java b/src/main/java/net/sdnlab/task31/ARPCache.java
new file mode 100644
index 00000000..c3193bb4
--- /dev/null
+++ b/src/main/java/net/sdnlab/task31/ARPCache.java
@@ -0,0 +1,15 @@
+package net.sdnlab.task31;
+import org.projectfloodlight.openflow.types.IPv4Address;
+
+import net.sdnlab.task31.ARPEntry;
+public class ARPCache {
+		public ARPEntry getEntryFromIP( IPv4Address ipAddress ) {
+			return null;	
+		}
+		public boolean contains( IPv4Address ipaddress ) {
+			return false;
+		}
+		public void storeEntry(ARPEntry entry ) {
+			
+		}
+}
diff --git a/src/main/java/net/sdnlab/task31/ARPEntry.java b/src/main/java/net/sdnlab/task31/ARPEntry.java
new file mode 100644
index 00000000..cb621f15
--- /dev/null
+++ b/src/main/java/net/sdnlab/task31/ARPEntry.java
@@ -0,0 +1,23 @@
+package net.sdnlab.task31;
+import org.projectfloodlight.openflow.types.MacAddress;
+import org.projectfloodlight.openflow.types.IPv4Address;
+public class ARPEntry {
+	private IPv4Address ipAddress;
+	private MacAddress macAddress;
+	
+	public IPv4Address getIpAddress() {
+		return ipAddress;
+	}
+	
+	public void setIpAddress(IPv4Address ipAddress) {
+		this.ipAddress = ipAddress;
+	}
+	
+	public MacAddress getMacAddress() {
+		return macAddress;
+	}
+	
+	public void setMacAddress(MacAddress macAddress) {
+		this.macAddress = macAddress;
+	}
+}
-- 
2.17.1


From 72e8c134d4077d46aed92abb47eb5141d2847bdd Mon Sep 17 00:00:00 2001
From: feeka <fikrattalibli@gmail.com>
Date: Fri, 30 Nov 2018 12:39:31 +0100
Subject: [PATCH 03/18] task23 configurations added

---
 src/main/java/net/sdnlab/common/Helper.java   |  6 ++
 ...htcontroller.core.module.IFloodlightModule |  3 +-
 src/main/resources/task23.properties          | 76 +++++++++++++++++++
 3 files changed, 84 insertions(+), 1 deletion(-)
 create mode 100644 src/main/resources/task23.properties

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
index 5ff8f2ea..7e0638dd 100644
--- a/src/main/java/net/sdnlab/common/Helper.java
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -4,3 +4,9 @@ package net.sdnlab.common;
  * @author fabian
  *
  */
+public class Helper{
+/*	public static boolean addIPBaseRouteToSwitch(Switch,outputport,ip_to_match,priority,timeout) {
+		// @ true on success false otherwise
+		return false;
+	}*/ 
+}
\ No newline at end of file
diff --git a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
index 0ff6a2bb..e7621fbc 100644
--- a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
+++ b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
@@ -29,4 +29,5 @@ net.floodlightcontroller.learningswitch.LearningSwitch
 net.floodlightcontroller.statistics.StatisticsCollector
 net.floodlightcontroller.routing.RoutingManager
 net.floodlightcontroller.cpanalyzer.CPAnalyzer
-net.floodlightcontroller.hasupport.HAController
\ No newline at end of file
+net.floodlightcontroller.hasupport.HAController
+net.sdnlab.ex2.Task23
diff --git a/src/main/resources/task23.properties b/src/main/resources/task23.properties
new file mode 100644
index 00000000..709b1828
--- /dev/null
+++ b/src/main/resources/task23.properties
@@ -0,0 +1,76 @@
+floodlight.modules=\
+net.floodlightcontroller.jython.JythonDebugInterface,\
+net.floodlightcontroller.storage.memory.MemoryStorageSource,\
+net.sdnlab.ex2.Task23,\
+net.floodlightcontroller.core.internal.FloodlightProvider,\
+net.floodlightcontroller.threadpool.ThreadPool,\
+net.floodlightcontroller.debugcounter.DebugCounterServiceImpl,\
+net.floodlightcontroller.perfmon.PktInProcessingTime,\
+net.floodlightcontroller.staticentry.StaticEntryPusher,\
+net.floodlightcontroller.restserver.RestApiServer,\
+net.floodlightcontroller.topology.TopologyManager,\
+net.floodlightcontroller.routing.RoutingManager,\
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager,\
+net.floodlightcontroller.ui.web.StaticWebRoutable,\
+net.floodlightcontroller.loadbalancer.LoadBalancer,\
+net.floodlightcontroller.firewall.Firewall,\
+net.floodlightcontroller.dhcpserver.DHCPServer,\
+net.floodlightcontroller.simpleft.FT,\
+net.floodlightcontroller.devicemanager.internal.DeviceManagerImpl,\
+net.floodlightcontroller.accesscontrollist.ACL,\
+net.floodlightcontroller.statistics.StatisticsCollector,\
+net.floodlightcontroller.hasupport.HAController
+org.sdnplatform.sync.internal.SyncManager.authScheme=CHALLENGE_RESPONSE
+org.sdnplatform.sync.internal.SyncManager.keyStorePath=/etc/floodlight/myKey.jceks
+org.sdnplatform.sync.internal.SyncManager.dbPath=/var/lib/floodlight/
+org.sdnplatform.sync.internal.SyncManager.keyStorePassword=syncPass
+org.sdnplatform.sync.internal.SyncManager.port=6642
+org.sdnplatform.sync.internal.SyncManager.thisNodeId=1
+org.sdnplatform.sync.internal.SyncManager.persistenceEnabled=FALSE
+org.sdnplatform.sync.internal.SyncManager.nodes=[\
+{"nodeId": 1, "domainId": 1, "hostname": "192.168.56.1", "port": 6642},\
+{"nodeId": 2, "domainId": 1, "hostname": "192.168.56.1", "port": 6643},\
+{"nodeId": 3, "domainId": 1, "hostname": "192.168.56.1", "port": 6644},\
+{"nodeId": 4, "domainId": 1, "hostname": "192.168.56.1", "port": 6645}\
+]
+net.floodlightcontroller.forwarding.Forwarding.match=in-port, vlan, mac, ip, transport, flag
+net.floodlightcontroller.forwarding.Forwarding.detailed-match=src-mac, dst-mac, src-ip, dst-ip, src-transport, dst-transport
+net.floodlightcontroller.forwarding.Forwarding.flood-arp=NO
+net.floodlightcontroller.forwarding.Forwarding.idle-timeout=5
+net.floodlightcontroller.forwarding.Forwarding.set-send-flow-rem-flag=FALSE
+net.floodlightcontroller.forwarding.Forwarding.remove-flows-on-link-or-port-down=TRUE
+net.floodlightcontroller.core.internal.FloodlightProvider.openFlowPort=6653
+net.floodlightcontroller.core.internal.FloodlightProvider.role=ACTIVE
+net.floodlightcontroller.core.internal.FloodlightProvider.controllerId=1
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-history-size=10
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-update-threshold=0.5
+net.floodlightcontroller.core.internal.FloodlightProvider.shutdownOnTransitionToStandby=true
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowPort=6653
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowAddresses=0.0.0.0
+net.floodlightcontroller.core.internal.OFSwitchManager.workerThreads=16
+net.floodlightcontroller.core.internal.OFSwitchManager.bossThreads=1
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionBacklog=1000
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionTimeoutMs=60000
+net.floodlightcontroller.core.internal.OFSwitchManager.defaultMaxTablesToReceiveTableMissFlow=1
+net.floodlightcontroller.core.internal.OFSwitchManager.maxTablesToReceiveTableMissFlowPerDpid={"00:00:00:00:00:00:00:01":"1","2":"1"}
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnInitialHandshakeAsMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnEachTransitionToMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePath=/path/to.jecks
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePassword=PassFL
+net.floodlightcontroller.core.internal.OFSwitchManager.useSsl=NO
+net.floodlightcontroller.core.internal.OFSwitchManager.supportedOpenFlowVersions=1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+net.floodlightcontroller.core.internal.OFSwitchManager.switchesInitialState={"00:00:00:00:00:00:00:01":"ROLE_MASTER","00:00:00:00:00:00:00:02":"ROLE_MASTER", "00:00:00:00:00:00:00:03":"ROLE_MASTER", "00:00:00:00:00:00:00:04":"ROLE_MASTER","00:00:00:00:00:00:00:05":"ROLE_MASTER","00:00:00:00:00:00:00:06":"ROLE_MASTER","00:00:00:00:00:00:00:07":"ROLE_MASTER","00:00:00:00:00:00:00:08":"ROLE_MASTER"}
+net.floodlightcontroller.restserver.RestApiServer.keyStorePath=/path/to.jceks
+net.floodlightcontroller.restserver.RestApiServer.keyStorePassword=Password
+net.floodlightcontroller.restserver.RestApiServer.httpsNeedClientAuthentication=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttps=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttp=YES
+net.floodlightcontroller.restserver.RestApiServer.httpsPort=8081
+net.floodlightcontroller.restserver.RestApiServer.httpPort=8080
+net.floodlightcontroller.restserver.RestApiServer.accessControlAllowAllOrigins=TRUE
+net.floodlightcontroller.statistics.StatisticsCollector.enable=FALSE
+net.floodlightcontroller.statistics.StatisticsCollector.collectionIntervalPortStatsSeconds=10
+net.floodlightcontroller.topology.TopologyManager.pathMetric=latency
+net.floodlightcontroller.topology.TopologyManager.maxPathsToCompute=3
+net.floodlightcontroller.hasupport.HAController.nodeid=1
+net.floodlightcontroller.hasupport.HAController.serverPort=127.0.0.1:4242
-- 
2.17.1


From 3c7082195ea63e89abb5a349f9c12df985fb95ec Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Fri, 30 Nov 2018 17:49:36 +0100
Subject: [PATCH 04/18] [ARPCACHE] Add class representing the Actual cash

ARPCache can, add,remove, store, and check if an ip address is known
ARPCache is threadsave
---
 src/main/java/net/sdnlab/task31/ARPCache.java | 53 ++++++++++++++++---
 src/main/java/net/sdnlab/task31/ARPEntry.java | 30 +++++++++++
 .../java/net/sdn/task31/ARPCacheTest.java     | 34 ++++++++++++
 3 files changed, 111 insertions(+), 6 deletions(-)
 create mode 100644 src/test/java/net/sdn/task31/ARPCacheTest.java

diff --git a/src/main/java/net/sdnlab/task31/ARPCache.java b/src/main/java/net/sdnlab/task31/ARPCache.java
index c3193bb4..5ff9d33a 100644
--- a/src/main/java/net/sdnlab/task31/ARPCache.java
+++ b/src/main/java/net/sdnlab/task31/ARPCache.java
@@ -1,15 +1,56 @@
 package net.sdnlab.task31;
+import java.util.HashMap;
+import java.util.Map;
+
 import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.MacAddress;
 
 import net.sdnlab.task31.ARPEntry;
 public class ARPCache {
-		public ARPEntry getEntryFromIP( IPv4Address ipAddress ) {
-			return null;	
+		// Use Map instead of Arrays of entries for faster search
+		private static Map<IPv4Address, MacAddress> arpEntries = new HashMap<IPv4Address,MacAddress>();
+		/**
+		 * Get an 
+		 * @param ipAddress
+		 * @return
+		 */
+		public synchronized ARPEntry getEntryFromIP( IPv4Address ipAddress ) {
+			MacAddress match = arpEntries.get(ipAddress);
+			 
+			if( match == null ) {
+				// This is considered an programming error ==> unchecked expection
+				throw new IllegalArgumentException("You should always check, if ARPEntry exists, before calling getEntryFromIP");
+			}
+			ARPEntry entry  = ARPEntry.of(ipAddress, arpEntries.get(ipAddress));
+			return entry;
+		}
+		
+		/**
+		 * @param ipAddress
+		 * @return True if the entry is in the cash, false if not
+		 */
+		public synchronized boolean contains( IPv4Address ipAddress ) {
+			return arpEntries.containsKey(ipAddress);
 		}
-		public boolean contains( IPv4Address ipaddress ) {
-			return false;
+		/**
+		 * Stores an ARPEntry with given information. A second store
+		 * will overwrite another ARPEntry with the <b> same </b> ip.
+		 * @param entry To store
+		 */
+		public synchronized void storeEntry( ARPEntry entry ) {
+			arpEntries.put(entry.getIpAddress(), entry.getMacAddress());
 		}
-		public void storeEntry(ARPEntry entry ) {
-			
+		
+		/**
+		 * Remove a ARPEntry identified by a given IPAddress,
+		 * Can not fail, if Entry does not exist, does nothing.
+		 * @param ipAddress Of the ARPEntry to delete
+		 */
+		public synchronized void deleteEntryByIp( IPv4Address ipAddress ) {
+			if ( arpEntries.containsKey(ipAddress) ) {
+				arpEntries.remove(ipAddress);
+			}
 		}
+		
+		
 }
diff --git a/src/main/java/net/sdnlab/task31/ARPEntry.java b/src/main/java/net/sdnlab/task31/ARPEntry.java
index cb621f15..9c8f6406 100644
--- a/src/main/java/net/sdnlab/task31/ARPEntry.java
+++ b/src/main/java/net/sdnlab/task31/ARPEntry.java
@@ -5,6 +5,19 @@ public class ARPEntry {
 	private IPv4Address ipAddress;
 	private MacAddress macAddress;
 	
+	/**
+	 * use static factory function idiom, as it is used in most other classes
+	 * here
+	 */
+	public static ARPEntry of(IPv4Address ipAddress, MacAddress macAddress) {
+		ARPEntry entry = new ARPEntry();
+		entry.setIpAddress(ipAddress);;
+		entry.setMacAddress(macAddress);
+		return entry;
+	}
+
+
+	
 	public IPv4Address getIpAddress() {
 		return ipAddress;
 	}
@@ -20,4 +33,21 @@ public class ARPEntry {
 	public void setMacAddress(MacAddress macAddress) {
 		this.macAddress = macAddress;
 	}
+	@Override 
+	public boolean equals(Object a ) {
+		if (!(a instanceof ARPEntry)) {
+			return false;
+		}
+		ARPEntry RHS = (ARPEntry) a;
+		if( RHS.getIpAddress().equals( this.getIpAddress() )
+		    && RHS.getMacAddress().equals(this.getMacAddress() )) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+	
+	private ARPEntry () {
+	}
+		
 }
diff --git a/src/test/java/net/sdn/task31/ARPCacheTest.java b/src/test/java/net/sdn/task31/ARPCacheTest.java
new file mode 100644
index 00000000..09c06428
--- /dev/null
+++ b/src/test/java/net/sdn/task31/ARPCacheTest.java
@@ -0,0 +1,34 @@
+package net.sdn.task31;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.MacAddress;
+
+import net.sdnlab.task31.ARPCache;
+import net.sdnlab.task31.ARPEntry;
+public class ARPCacheTest {
+	@Test
+	public void testBasics() {
+		ARPCache cache = new ARPCache();
+		// Check if i can store entries
+		cache.storeEntry(ARPEntry.of(IPv4Address.of("127.0.0.1"), MacAddress.of("11:22:33:44:55:66")));
+		assertTrue( cache.contains( IPv4Address.of("127.0.0.1")) );
+		// check if we don't have "wrong" entries"
+		assertFalse( cache.contains(IPv4Address.of("127.0.0.2")) );
+		
+		// store another entry
+		ARPEntry entry = ARPEntry.of(IPv4Address.of("127.0.0.2"), MacAddress.of("00:22:33:44:55:66"));
+		cache.storeEntry(entry);
+		assertTrue( cache.contains(IPv4Address.of("127.0.0.2")) );
+		// check if it is really the same
+		ARPEntry entToCompare = cache.getEntryFromIP(IPv4Address.of("127.0.0.2"));
+		assertEquals(entry, entToCompare );
+		
+		// now, maybe from time to time we want to delete entries
+		cache.deleteEntryByIp( IPv4Address.of("127.0.0.2"));
+		assertFalse( cache.contains(IPv4Address.of("127.0.0.2")) );
+	}
+}
-- 
2.17.1


From 2db5aeb5e934cbd27e9b283b52fb7ca23db0be47 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Fri, 30 Nov 2018 17:53:29 +0100
Subject: [PATCH 05/18] [BUGFIX] rename to match to Assignment requirements

---
 src/main/java/net/sdnlab/{task31 => ex3}/ARPCache.java  | 4 ++--
 src/main/java/net/sdnlab/{task31 => ex3}/ARPEntry.java  | 2 +-
 src/test/java/net/sdn/{task31 => ex3}/ARPCacheTest.java | 6 +++---
 3 files changed, 6 insertions(+), 6 deletions(-)
 rename src/main/java/net/sdnlab/{task31 => ex3}/ARPCache.java (96%)
 rename src/main/java/net/sdnlab/{task31 => ex3}/ARPEntry.java (97%)
 rename src/test/java/net/sdn/{task31 => ex3}/ARPCacheTest.java (92%)

diff --git a/src/main/java/net/sdnlab/task31/ARPCache.java b/src/main/java/net/sdnlab/ex3/ARPCache.java
similarity index 96%
rename from src/main/java/net/sdnlab/task31/ARPCache.java
rename to src/main/java/net/sdnlab/ex3/ARPCache.java
index 5ff9d33a..2a9446cb 100644
--- a/src/main/java/net/sdnlab/task31/ARPCache.java
+++ b/src/main/java/net/sdnlab/ex3/ARPCache.java
@@ -1,11 +1,11 @@
-package net.sdnlab.task31;
+package net.sdnlab.ex3;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.MacAddress;
 
-import net.sdnlab.task31.ARPEntry;
+import net.sdnlab.ex3.ARPEntry;
 public class ARPCache {
 		// Use Map instead of Arrays of entries for faster search
 		private static Map<IPv4Address, MacAddress> arpEntries = new HashMap<IPv4Address,MacAddress>();
diff --git a/src/main/java/net/sdnlab/task31/ARPEntry.java b/src/main/java/net/sdnlab/ex3/ARPEntry.java
similarity index 97%
rename from src/main/java/net/sdnlab/task31/ARPEntry.java
rename to src/main/java/net/sdnlab/ex3/ARPEntry.java
index 9c8f6406..252c4142 100644
--- a/src/main/java/net/sdnlab/task31/ARPEntry.java
+++ b/src/main/java/net/sdnlab/ex3/ARPEntry.java
@@ -1,4 +1,4 @@
-package net.sdnlab.task31;
+package net.sdnlab.ex3;
 import org.projectfloodlight.openflow.types.MacAddress;
 import org.projectfloodlight.openflow.types.IPv4Address;
 public class ARPEntry {
diff --git a/src/test/java/net/sdn/task31/ARPCacheTest.java b/src/test/java/net/sdn/ex3/ARPCacheTest.java
similarity index 92%
rename from src/test/java/net/sdn/task31/ARPCacheTest.java
rename to src/test/java/net/sdn/ex3/ARPCacheTest.java
index 09c06428..be20b808 100644
--- a/src/test/java/net/sdn/task31/ARPCacheTest.java
+++ b/src/test/java/net/sdn/ex3/ARPCacheTest.java
@@ -1,4 +1,4 @@
-package net.sdn.task31;
+package net.sdn.ex3;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -7,8 +7,8 @@ import org.junit.Test;
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.MacAddress;
 
-import net.sdnlab.task31.ARPCache;
-import net.sdnlab.task31.ARPEntry;
+import net.sdnlab.ex3.ARPCache;
+import net.sdnlab.ex3.ARPEntry;
 public class ARPCacheTest {
 	@Test
 	public void testBasics() {
-- 
2.17.1


From b831be0b72778ea9c761aa839472d8c5b9f916f6 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Fri, 30 Nov 2018 18:06:25 +0100
Subject: [PATCH 06/18] [TASK31] Added Task31 Module

---
 src/main/java/net/sdnlab/ex3/ARPEntry.java    |  3 +-
 src/main/java/net/sdnlab/ex3/Task31.java      | 48 ++++++++++++
 ...htcontroller.core.module.IFloodlightModule |  1 +
 src/main/resources/task23.properties          |  4 +-
 src/main/resources/task31.properties          | 76 +++++++++++++++++++
 5 files changed, 128 insertions(+), 4 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/Task31.java
 create mode 100644 src/main/resources/task31.properties

diff --git a/src/main/java/net/sdnlab/ex3/ARPEntry.java b/src/main/java/net/sdnlab/ex3/ARPEntry.java
index 252c4142..a53fbcee 100644
--- a/src/main/java/net/sdnlab/ex3/ARPEntry.java
+++ b/src/main/java/net/sdnlab/ex3/ARPEntry.java
@@ -11,13 +11,12 @@ public class ARPEntry {
 	 */
 	public static ARPEntry of(IPv4Address ipAddress, MacAddress macAddress) {
 		ARPEntry entry = new ARPEntry();
-		entry.setIpAddress(ipAddress);;
+		entry.setIpAddress(ipAddress);
 		entry.setMacAddress(macAddress);
 		return entry;
 	}
 
 
-	
 	public IPv4Address getIpAddress() {
 		return ipAddress;
 	}
diff --git a/src/main/java/net/sdnlab/ex3/Task31.java b/src/main/java/net/sdnlab/ex3/Task31.java
new file mode 100644
index 00000000..cb3bc31a
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/Task31.java
@@ -0,0 +1,48 @@
+package net.sdnlab.ex3;
+
+import java.util.Collection;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.module.FloodlightModuleContext;
+import net.floodlightcontroller.core.module.FloodlightModuleException;
+import net.floodlightcontroller.core.module.IFloodlightModule;
+import net.floodlightcontroller.core.module.IFloodlightService;
+import net.sdnlab.ex2.Task23;
+
+public class Task31 implements IFloodlightModule {
+	private static Logger logger;
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
+		logger = LoggerFactory.getLogger(Task31.class);
+		logger.info("Loaded Module");
+
+	}
+
+	@Override
+	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
index e7621fbc..0340c080 100644
--- a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
+++ b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
@@ -31,3 +31,4 @@ net.floodlightcontroller.routing.RoutingManager
 net.floodlightcontroller.cpanalyzer.CPAnalyzer
 net.floodlightcontroller.hasupport.HAController
 net.sdnlab.ex2.Task23
+net.sdnlab.ex3.Task31
diff --git a/src/main/resources/task23.properties b/src/main/resources/task23.properties
index 709b1828..b012d25f 100644
--- a/src/main/resources/task23.properties
+++ b/src/main/resources/task23.properties
@@ -1,7 +1,6 @@
 floodlight.modules=\
 net.floodlightcontroller.jython.JythonDebugInterface,\
 net.floodlightcontroller.storage.memory.MemoryStorageSource,\
-net.sdnlab.ex2.Task23,\
 net.floodlightcontroller.core.internal.FloodlightProvider,\
 net.floodlightcontroller.threadpool.ThreadPool,\
 net.floodlightcontroller.debugcounter.DebugCounterServiceImpl,\
@@ -19,7 +18,8 @@ net.floodlightcontroller.simpleft.FT,\
 net.floodlightcontroller.devicemanager.internal.DeviceManagerImpl,\
 net.floodlightcontroller.accesscontrollist.ACL,\
 net.floodlightcontroller.statistics.StatisticsCollector,\
-net.floodlightcontroller.hasupport.HAController
+net.floodlightcontroller.hasupport.HAController, \
+net.sdnlab.ex2.Task23
 org.sdnplatform.sync.internal.SyncManager.authScheme=CHALLENGE_RESPONSE
 org.sdnplatform.sync.internal.SyncManager.keyStorePath=/etc/floodlight/myKey.jceks
 org.sdnplatform.sync.internal.SyncManager.dbPath=/var/lib/floodlight/
diff --git a/src/main/resources/task31.properties b/src/main/resources/task31.properties
new file mode 100644
index 00000000..af3cd3d1
--- /dev/null
+++ b/src/main/resources/task31.properties
@@ -0,0 +1,76 @@
+floodlight.modules=\
+net.floodlightcontroller.jython.JythonDebugInterface,\
+net.floodlightcontroller.storage.memory.MemoryStorageSource,\
+net.floodlightcontroller.core.internal.FloodlightProvider,\
+net.floodlightcontroller.threadpool.ThreadPool,\
+net.floodlightcontroller.debugcounter.DebugCounterServiceImpl,\
+net.floodlightcontroller.perfmon.PktInProcessingTime,\
+net.floodlightcontroller.staticentry.StaticEntryPusher,\
+net.floodlightcontroller.restserver.RestApiServer,\
+net.floodlightcontroller.topology.TopologyManager,\
+net.floodlightcontroller.routing.RoutingManager,\
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager,\
+net.floodlightcontroller.ui.web.StaticWebRoutable,\
+net.floodlightcontroller.loadbalancer.LoadBalancer,\
+net.floodlightcontroller.firewall.Firewall,\
+net.floodlightcontroller.dhcpserver.DHCPServer,\
+net.floodlightcontroller.simpleft.FT,\
+net.floodlightcontroller.devicemanager.internal.DeviceManagerImpl,\
+net.floodlightcontroller.accesscontrollist.ACL,\
+net.floodlightcontroller.statistics.StatisticsCollector,\
+net.floodlightcontroller.hasupport.HAController, \
+net.sdnlab.ex3.Task31
+org.sdnplatform.sync.internal.SyncManager.authScheme=CHALLENGE_RESPONSE
+org.sdnplatform.sync.internal.SyncManager.keyStorePath=/etc/floodlight/myKey.jceks
+org.sdnplatform.sync.internal.SyncManager.dbPath=/var/lib/floodlight/
+org.sdnplatform.sync.internal.SyncManager.keyStorePassword=syncPass
+org.sdnplatform.sync.internal.SyncManager.port=6642
+org.sdnplatform.sync.internal.SyncManager.thisNodeId=1
+org.sdnplatform.sync.internal.SyncManager.persistenceEnabled=FALSE
+org.sdnplatform.sync.internal.SyncManager.nodes=[\
+{"nodeId": 1, "domainId": 1, "hostname": "192.168.56.1", "port": 6642},\
+{"nodeId": 2, "domainId": 1, "hostname": "192.168.56.1", "port": 6643},\
+{"nodeId": 3, "domainId": 1, "hostname": "192.168.56.1", "port": 6644},\
+{"nodeId": 4, "domainId": 1, "hostname": "192.168.56.1", "port": 6645}\
+]
+net.floodlightcontroller.forwarding.Forwarding.match=in-port, vlan, mac, ip, transport, flag
+net.floodlightcontroller.forwarding.Forwarding.detailed-match=src-mac, dst-mac, src-ip, dst-ip, src-transport, dst-transport
+net.floodlightcontroller.forwarding.Forwarding.flood-arp=NO
+net.floodlightcontroller.forwarding.Forwarding.idle-timeout=5
+net.floodlightcontroller.forwarding.Forwarding.set-send-flow-rem-flag=FALSE
+net.floodlightcontroller.forwarding.Forwarding.remove-flows-on-link-or-port-down=TRUE
+net.floodlightcontroller.core.internal.FloodlightProvider.openFlowPort=6653
+net.floodlightcontroller.core.internal.FloodlightProvider.role=ACTIVE
+net.floodlightcontroller.core.internal.FloodlightProvider.controllerId=1
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-history-size=10
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-update-threshold=0.5
+net.floodlightcontroller.core.internal.FloodlightProvider.shutdownOnTransitionToStandby=true
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowPort=6653
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowAddresses=0.0.0.0
+net.floodlightcontroller.core.internal.OFSwitchManager.workerThreads=16
+net.floodlightcontroller.core.internal.OFSwitchManager.bossThreads=1
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionBacklog=1000
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionTimeoutMs=60000
+net.floodlightcontroller.core.internal.OFSwitchManager.defaultMaxTablesToReceiveTableMissFlow=1
+net.floodlightcontroller.core.internal.OFSwitchManager.maxTablesToReceiveTableMissFlowPerDpid={"00:00:00:00:00:00:00:01":"1","2":"1"}
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnInitialHandshakeAsMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnEachTransitionToMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePath=/path/to.jecks
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePassword=PassFL
+net.floodlightcontroller.core.internal.OFSwitchManager.useSsl=NO
+net.floodlightcontroller.core.internal.OFSwitchManager.supportedOpenFlowVersions=1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+net.floodlightcontroller.core.internal.OFSwitchManager.switchesInitialState={"00:00:00:00:00:00:00:01":"ROLE_MASTER","00:00:00:00:00:00:00:02":"ROLE_MASTER", "00:00:00:00:00:00:00:03":"ROLE_MASTER", "00:00:00:00:00:00:00:04":"ROLE_MASTER","00:00:00:00:00:00:00:05":"ROLE_MASTER","00:00:00:00:00:00:00:06":"ROLE_MASTER","00:00:00:00:00:00:00:07":"ROLE_MASTER","00:00:00:00:00:00:00:08":"ROLE_MASTER"}
+net.floodlightcontroller.restserver.RestApiServer.keyStorePath=/path/to.jceks
+net.floodlightcontroller.restserver.RestApiServer.keyStorePassword=Password
+net.floodlightcontroller.restserver.RestApiServer.httpsNeedClientAuthentication=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttps=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttp=YES
+net.floodlightcontroller.restserver.RestApiServer.httpsPort=8081
+net.floodlightcontroller.restserver.RestApiServer.httpPort=8080
+net.floodlightcontroller.restserver.RestApiServer.accessControlAllowAllOrigins=TRUE
+net.floodlightcontroller.statistics.StatisticsCollector.enable=FALSE
+net.floodlightcontroller.statistics.StatisticsCollector.collectionIntervalPortStatsSeconds=10
+net.floodlightcontroller.topology.TopologyManager.pathMetric=latency
+net.floodlightcontroller.topology.TopologyManager.maxPathsToCompute=3
+net.floodlightcontroller.hasupport.HAController.nodeid=1
+net.floodlightcontroller.hasupport.HAController.serverPort=127.0.0.1:4242
-- 
2.17.1


From 895f122edc96737be6a1e65ee016d9a4f3685074 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Sat, 1 Dec 2018 18:38:32 +0100
Subject: [PATCH 07/18] [TASK31] Solution (still needs some cleaning, but
 works)

---
 src/main/java/net/sdnlab/common/Helper.java  |  56 +++++
 src/main/java/net/sdnlab/ex3/ARPEntry.java   |   5 +
 src/main/java/net/sdnlab/ex3/ARPHandler.java | 234 +++++++++++++++++++
 src/main/java/net/sdnlab/ex3/Task31.java     | 119 +++++++++-
 4 files changed, 409 insertions(+), 5 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/ARPHandler.java

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
index 7e0638dd..c5349eae 100644
--- a/src/main/java/net/sdnlab/common/Helper.java
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -1,4 +1,21 @@
 package net.sdnlab.common;
+
+import java.util.ArrayList;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowAdd;
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.protocol.action.OFActions;
+import org.projectfloodlight.openflow.protocol.match.Match;
+import org.projectfloodlight.openflow.protocol.match.MatchField;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.OFPort;
+import org.projectfloodlight.openflow.types.U64;
+
+import net.floodlightcontroller.core.IOFSwitch;
+
+
 /**
  * Class used for common Function based calls...
  * @author fabian
@@ -9,4 +26,43 @@ public class Helper{
 		// @ true on success false otherwise
 		return false;
 	}*/ 
+	
+	public static boolean updateSwitch (IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort) {
+		return updateSwitch( switchToUpdate, ipToMatch, outputPort, U64.of(0xcafe), 32700);
+	}
+	
+	public static boolean updateSwitch(IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort, U64 flowNumber, int flowPriority) {	
+		// we want to use a factory, definitely matching to the switch
+		// so instead of using generic factory with version, we 
+		// always use the factory provided by the switch
+		OFFactory factoryToUse = switchToUpdate.getOFFactory();
+		
+		// which packets to match
+		Match match = factoryToUse.buildMatch()
+				.setExact(MatchField.ETH_TYPE, EthType.IPv4)
+				.setExact(MatchField.IPV4_DST,ipToMatch)
+				.build();
+		
+		
+		// create specific actions
+		ArrayList<OFAction> actionList = new ArrayList<OFAction>();
+		OFActions actions = factoryToUse.actions();
+		actionList.add(
+				actions.buildOutput()
+				.setMaxLen(0xFFffFFff)
+				.setPort(OFPort.of(outputPort))
+				.build());
+		
+		// create the flow message
+		OFFlowAdd flowAdd = factoryToUse.buildFlowAdd()
+				.setCookie(flowNumber)
+				.setPriority(flowPriority)
+				.setMatch(match)
+				.setActions(actionList)
+				.build();
+		
+		// check if it was  successfully written to the switch
+		boolean wasSuccess = switchToUpdate.write(flowAdd);
+		return wasSuccess;
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/net/sdnlab/ex3/ARPEntry.java b/src/main/java/net/sdnlab/ex3/ARPEntry.java
index a53fbcee..fb82a9a5 100644
--- a/src/main/java/net/sdnlab/ex3/ARPEntry.java
+++ b/src/main/java/net/sdnlab/ex3/ARPEntry.java
@@ -46,6 +46,11 @@ public class ARPEntry {
 		}
 	}
 	
+	@Override
+	public String toString() {
+		return "[ " + this.macAddress.toString()+", " + this.ipAddress.toString() + " ]";  
+	}
+	
 	private ARPEntry () {
 	}
 		
diff --git a/src/main/java/net/sdnlab/ex3/ARPHandler.java b/src/main/java/net/sdnlab/ex3/ARPHandler.java
new file mode 100644
index 00000000..e9c1b2ed
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/ARPHandler.java
@@ -0,0 +1,234 @@
+package net.sdnlab.ex3;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.MacAddress;
+import org.projectfloodlight.openflow.types.OFPort;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFMessage;
+import org.projectfloodlight.openflow.protocol.OFPacketOut;
+import org.projectfloodlight.openflow.protocol.OFType;
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+
+import net.floodlightcontroller.core.FloodlightContext;
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.IOFMessageListener;
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.packet.ARP;
+import net.floodlightcontroller.packet.Ethernet;
+import org.projectfloodlight.openflow.types.ArpOpcode;
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.EthType;
+/**
+ * ARPHandler does all neccesary actions, to handle arp requests
+ * @author fabian
+ *
+ */
+
+public class ARPHandler implements IOFMessageListener {
+	private IOFSwitchService switchService;
+	
+	private static Logger logger;
+	
+	// We need to know on which switch is which, host
+	private class HostInfo {
+		public HostInfo(DatapathId switchId, int outPutPort) {
+			super();
+			this.switchId = switchId;
+			this.outPutPort = outPutPort;
+		}
+		private DatapathId switchId;
+		private int outPutPort;
+		
+		public DatapathId getSwitchId() {
+			return switchId;
+		}
+		public int getOutPutPort() {
+			return outPutPort;
+		}
+	}
+	
+	
+	// hardcode topology
+	private Map <IPv4Address, HostInfo> switches = new HashMap<IPv4Address, HostInfo>();
+	
+	private ARPCache arpCache = new ARPCache();
+	
+	
+	public ARPHandler( IOFSwitchService switchService) {
+		// fill topology info by hand
+		switches.put(IPv4Address.of("10.10.1.1"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:01"), 1));
+		switches.put(IPv4Address.of("10.10.1.2"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:01"), 2));
+		switches.put(IPv4Address.of("10.10.1.3"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:01"), 3));
+		
+		switches.put(IPv4Address.of("10.10.2.1"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:02"), 1));
+		switches.put(IPv4Address.of("10.10.2.2"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:02"), 2));
+		switches.put(IPv4Address.of("10.10.2.3"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:02"), 3));
+		
+		switches.put(IPv4Address.of("10.10.4.1"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:04"), 1));
+		switches.put(IPv4Address.of("10.10.4.2"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:04"), 2));
+		switches.put(IPv4Address.of("10.10.4.3"), new HostInfo(DatapathId.of("00:00:00:00:00:00:00:04"), 3));
+		
+		this.switchService = switchService;
+		
+		logger = LoggerFactory.getLogger(ARPHandler.class);
+	}
+	
+	
+	
+	private HostInfo getSwitch(IPv4Address addr) {
+		if( switches.containsKey(addr)) {
+			return switches.get(addr);
+		} else {
+			return null;
+		}
+	}
+	
+	
+	@Override
+	public String getName() {
+		// TODO Auto-generated method stub
+		return this.getClass().getName();
+	}
+
+	@Override
+	public boolean isCallbackOrderingPrereq(OFType type, String name) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isCallbackOrderingPostreq(OFType type, String name) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
+		Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);
+		// check if we have a packet of the right type
+		if( eth.getEtherType().equals(EthType.ARP)) {				
+			ARP payload = (ARP) eth.getPayload();
+			ArpOpcode opcode  = payload.getOpCode();
+			if( opcode == ArpOpcode.REQUEST ) {
+				handleARPRequest(sw, msg, cntx, payload );
+			} else if ( opcode == ArpOpcode.REPLY ) {
+				handleARPReply(sw, msg, cntx, payload );
+			} else {
+				logger.info("Unhandeld ARPOpcode of type " + opcode.toString() );
+			}
+			// no one else should handle arp requests
+			return Command.STOP;
+		}
+		return Command.CONTINUE;
+	}
+	
+	private void handleARPRequest(IOFSwitch sw, OFMessage msg, FloodlightContext cntx, ARP payload ) {
+		logger.info("Handling ARPRequest from " +  payload.getSenderProtocolAddress() );
+		// first check, if we want to store the sender
+		ARPEntry requestSender = ARPEntry.of(payload.getSenderProtocolAddress(), payload.getSenderHardwareAddress());
+		if( !arpCache.contains(payload.getSenderProtocolAddress()) ) {
+			
+			arpCache.storeEntry(requestSender);
+			logger.info("Stored " + requestSender );
+		}
+		
+		if( arpCache.contains(payload.getTargetProtocolAddress())) {
+			ARPEntry lookedForHost = arpCache.getEntryFromIP(payload.getTargetProtocolAddress());
+			ARPEntry destination = requestSender;
+			Ethernet packetToInject = createARPPacket( lookedForHost, destination, ArpOpcode.REPLY);
+			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
+			logger.info("Inject reply\n----------" + packetToInject  + "\n----------was success " + success );
+		} else {
+			ARPEntry destination = ARPEntry.of( payload.getTargetProtocolAddress(), MacAddress.of("FF:FF:FF:FF:FF:FF"));
+			Ethernet packetToInject = createARPPacket(requestSender, destination, ArpOpcode.REQUEST);
+			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
+			logger.info("Inject request\n--------------" + packetToInject  + "\n-----------\nwas success " + success );
+		}
+	}
+	
+/**
+ * 
+ * @param source ARPEntry of the source
+ * @param destination ARPEntry of the destination addr
+ * @param operation The Operation to do
+ * @return returns a Ethernet packet ready for injection
+ */
+	
+	private Ethernet createARPPacket(ARPEntry source, ARPEntry destination, ArpOpcode operation ) {	
+		// create the arp Payload
+		ARP payload = new ARP();
+		// common values
+		payload.setHardwareType((short)1);
+		payload.setProtocolType((short)0x0800);
+		payload.setHardwareAddressLength((byte) 6 );
+		payload.setProtocolAddressLength((byte)4);
+		//operation to do
+		payload.setOpCode(operation);
+		// setting the important source and destinatino fields
+		payload.setSenderHardwareAddress(source.getMacAddress());
+		payload.setSenderProtocolAddress(source.getIpAddress());
+		payload.setTargetHardwareAddress(destination.getMacAddress());
+		payload.setTargetProtocolAddress(destination.getIpAddress());
+		
+		// fill the corresponding ethernet packet
+		Ethernet packet = new Ethernet();
+		packet.setEtherType(EthType.ARP);
+		packet.setPayload(payload);
+		packet.setDestinationMACAddress(destination.getMacAddress());
+		packet.setSourceMACAddress(source.getMacAddress());
+		
+		return packet;
+	}
+	
+	private boolean injectPacketForHost(IPv4Address hostAddr, Ethernet packet) {
+		// First find out on which switch and port to inject
+		HostInfo info  = getSwitch(hostAddr);
+		if( info == null) {
+			logger.info("Could not find a switch for host" + hostAddr);
+			return false;
+		}
+		// get the attached switch and outputport
+		IOFSwitch switchToUse = this.switchService.getSwitch(info.switchId);
+		int outputPort = info.getOutPutPort();
+		
+		//now we can serialize the packet again, and send it to the second switch
+		byte[] serializedPacket= packet.serialize();
+		OFFactory switchFactory = switchToUse.getOFFactory();
+		
+		// still ugly, but i don't care
+		List<OFAction> actions = Collections.singletonList(
+					(OFAction)switchFactory.actions().output(OFPort.of(info.getOutPutPort()), 0xffFFffFF)
+				);
+		OFPacketOut po = switchFactory.buildPacketOut()
+				.setData(serializedPacket)
+				.setActions(actions)
+				.setInPort(OFPort.CONTROLLER)
+				.build();
+		// finally write to output
+		return switchToUse.write(po);
+	}
+	
+	private void handleARPReply(IOFSwitch sw, OFMessage msg, FloodlightContext cnt, ARP payload  ) {
+		if( ! arpCache.contains(payload.getSenderProtocolAddress() )) {
+			arpCache.storeEntry( ARPEntry.of(payload.getSenderProtocolAddress(), payload.getTargetHardwareAddress()));
+		} 
+		if( arpCache.contains( payload.getTargetProtocolAddress() )) {
+			ARPEntry lookedForHost = arpCache.getEntryFromIP(payload.getSenderProtocolAddress());
+			ARPEntry destination = arpCache.getEntryFromIP(payload.getTargetProtocolAddress() );
+			Ethernet packetToInject = createARPPacket( lookedForHost, destination, ArpOpcode.REPLY);
+			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
+			logger.info("Inject reply\n----------" + packetToInject  + "\n----------\nwas success " + success );
+		} else {
+			logger.error("Receiving an ARP Reply to an Request we have not Seen:\n" + payload);
+		}
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex3/Task31.java b/src/main/java/net/sdnlab/ex3/Task31.java
index cb3bc31a..f9900711 100644
--- a/src/main/java/net/sdnlab/ex3/Task31.java
+++ b/src/main/java/net/sdnlab/ex3/Task31.java
@@ -1,19 +1,35 @@
 package net.sdnlab.ex3;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Map;
 
+import org.projectfloodlight.openflow.protocol.OFPortDesc;
+import org.projectfloodlight.openflow.protocol.OFType;
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.IPv4Address;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.IOFSwitchListener;
+import net.floodlightcontroller.core.PortChangeType;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
 import net.floodlightcontroller.core.module.FloodlightModuleContext;
 import net.floodlightcontroller.core.module.FloodlightModuleException;
 import net.floodlightcontroller.core.module.IFloodlightModule;
 import net.floodlightcontroller.core.module.IFloodlightService;
-import net.sdnlab.ex2.Task23;
+import net.floodlightcontroller.threadpool.IThreadPoolService;
+
+import static net.sdnlab.common.Helper.updateSwitch;
 
-public class Task31 implements IFloodlightModule {
+public class Task31 implements IFloodlightModule, IOFSwitchListener {
 	private static Logger logger;
+	private IOFSwitchService switchService;
+	private IFloodlightProviderService floodlightProviderService;
+	private ARPHandler arpHandler;
 	@Override
 	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
 		// TODO Auto-generated method stub
@@ -28,21 +44,114 @@ public class Task31 implements IFloodlightModule {
 
 	@Override
 	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
-		// TODO Auto-generated method stub
-		return null;
+		Collection<Class<? extends IFloodlightService>> moduleDependencies = new
+					ArrayList<Class<? extends IFloodlightService>>();
+			moduleDependencies.add(IFloodlightProviderService.class);
+			moduleDependencies.add(IOFSwitchService.class);
+			moduleDependencies.add(IThreadPoolService.class);
+		 return moduleDependencies;
 	}
 
 	@Override
 	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
 		logger = LoggerFactory.getLogger(Task31.class);
 		logger.info("Loaded Module");
-
+		this.switchService = context.getServiceImpl(IOFSwitchService.class);
+		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
+		this.arpHandler = new ARPHandler( this.switchService );
 	}
 
 	@Override
 	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		this.switchService.addOFSwitchListener(this);
+		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.arpHandler);
+	}
+
+	@Override
+	public void switchAdded(DatapathId switchId) {
+
+		
+	}
+
+	@Override
+	public void switchRemoved(DatapathId switchId) {
+		logger.info( "Switch removed" + switchId);
+		
+	}
+
+	@Override
+	public void switchActivated(DatapathId switchId) {
+		logger.info( "Switch activated installing config..." + switchId);
+		IOFSwitch switchToUpdate  = this.switchService.getSwitch(switchId);
+		boolean success= true;
+		if( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:01")) ) {
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 3);
+			
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+						
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:02") ) ) {
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 4);
+			
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 3);
+					
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:03") ) ){
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 1);
+			
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
+					
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
+		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:04") ) ){
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 4);
+			
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+					
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 3);
+		}
+		logger.info("Installing config was success: " + success);
+	}
+
+	@Override
+	public void switchPortChanged(DatapathId switchId, OFPortDesc port, PortChangeType type) {
+		logger.info( "Switchport activated" + switchId);
+		
+	}
+
+	@Override
+	public void switchChanged(DatapathId switchId) {
 		// TODO Auto-generated method stub
+		
+	}
 
+	@Override
+	public void switchDeactivated(DatapathId switchId) {
+		// TODO Auto-generated method stub
+		
 	}
 
 }
-- 
2.17.1


From 83526ddc0490d56b6e1b65533e8377fd50b7b79a Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 14:45:26 +0100
Subject: [PATCH 08/18] [TASK32] Added Dijkstra implementation and "play
 around" unit test

---
 src/main/java/net/sdnlab/common/Helper.java   | 10 ++
 .../net/sdnlab/common/dijkstra/Dijkstra.java  | 97 +++++++++++++++++++
 .../net/sdnlab/common/dijkstra/NodeDist.java  | 56 +++++++++++
 .../sdnlab/common/dijkstra/package-info.java  |  7 ++
 src/test/java/net/sdn/ex3/Task32Test.java     | 87 +++++++++++++++++
 5 files changed, 257 insertions(+)
 create mode 100644 src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
 create mode 100644 src/main/java/net/sdnlab/common/dijkstra/NodeDist.java
 create mode 100644 src/main/java/net/sdnlab/common/dijkstra/package-info.java
 create mode 100644 src/test/java/net/sdn/ex3/Task32Test.java

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
index c5349eae..3d302912 100644
--- a/src/main/java/net/sdnlab/common/Helper.java
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -1,6 +1,10 @@
 package net.sdnlab.common;
 
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.PriorityQueue;
+import java.util.Set;
 
 import org.projectfloodlight.openflow.protocol.OFFactory;
 import org.projectfloodlight.openflow.protocol.OFFlowAdd;
@@ -8,12 +12,15 @@ import org.projectfloodlight.openflow.protocol.action.OFAction;
 import org.projectfloodlight.openflow.protocol.action.OFActions;
 import org.projectfloodlight.openflow.protocol.match.Match;
 import org.projectfloodlight.openflow.protocol.match.MatchField;
+import org.projectfloodlight.openflow.types.DatapathId;
 import org.projectfloodlight.openflow.types.EthType;
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.OFPort;
 import org.projectfloodlight.openflow.types.U64;
 
 import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.linkdiscovery.Link;
+import net.floodlightcontroller.routing.BroadcastTree;
 
 
 /**
@@ -65,4 +72,7 @@ public class Helper{
 		boolean wasSuccess = switchToUpdate.write(flowAdd);
 		return wasSuccess;
 	}
+	
+	
+	
 }
\ No newline at end of file
diff --git a/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
new file mode 100644
index 00000000..f22cc305
--- /dev/null
+++ b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
@@ -0,0 +1,97 @@
+package net.sdnlab.common.dijkstra;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.PriorityQueue;
+import java.util.Set;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import net.floodlightcontroller.linkdiscovery.Link;
+import net.floodlightcontroller.routing.BroadcastTree;
+
+public class Dijkstra {
+	/*
+     * Dijkstra that calculates destination rooted trees over the entire topology.
+     */
+	private static final Logger log = LoggerFactory.getLogger(Dijkstra.class.getName());
+    public static final int MAX_LINK_WEIGHT = 10000;
+    public static final int MAX_PATH_WEIGHT = Integer.MAX_VALUE - MAX_LINK_WEIGHT - 1;
+    public static BroadcastTree compute(Map<DatapathId, Set<Link>> links, DatapathId root,
+            Map<Link, Integer> linkCost,
+            boolean isDstRooted) {
+        HashMap<DatapathId, Link> nexthoplinks = new HashMap<DatapathId, Link>();
+        HashMap<DatapathId, Integer> cost = new HashMap<DatapathId, Integer>();
+        int w;
+
+        for (DatapathId node : links.keySet()) {
+            nexthoplinks.put(node, null);
+            cost.put(node, MAX_PATH_WEIGHT);
+            //log.debug("Added max cost to {}", node);
+        }
+
+        HashMap<DatapathId, Boolean> seen = new HashMap<DatapathId, Boolean>();
+        PriorityQueue<NodeDist> nodeq = new PriorityQueue<NodeDist>();
+        nodeq.add(new NodeDist(root, 0));
+        cost.put(root, 0);
+
+        //log.debug("{}", links);
+
+        while (nodeq.peek() != null) {
+            NodeDist n = nodeq.poll();
+            DatapathId cnode = n.getNode();
+            int cdist = n.getDist();
+
+            if (cdist >= MAX_PATH_WEIGHT) break;
+            if (seen.containsKey(cnode)) continue;
+            seen.put(cnode, true);
+
+            //log.debug("cnode {} and links {}", cnode, links.get(cnode));
+            if (links.get(cnode) == null) continue;
+            for (Link link : links.get(cnode)) {
+                DatapathId neighbor;
+
+                if (isDstRooted == true) {
+                    neighbor = link.getSrc();
+                } else {
+                    neighbor = link.getDst();
+                }
+
+                // links directed toward cnode will result in this condition
+                if (neighbor.equals(cnode)) continue;
+
+                if (seen.containsKey(neighbor)) continue;
+
+                if (linkCost == null || linkCost.get(link) == null) {
+                    w = 1;
+                } else {
+                    w = linkCost.get(link);
+                }
+
+                int ndist = cdist + w; // the weight of the link, always 1 in current version of floodlight.
+                log.debug("Neighbor: {}", neighbor);
+                log.debug("Cost: {}", cost);
+                log.debug("Neighbor cost: {}", cost.get(neighbor));
+
+                if (ndist < cost.get(neighbor)) {
+                    cost.put(neighbor, ndist);
+                    nexthoplinks.put(neighbor, link);
+
+                    NodeDist ndTemp = new NodeDist(neighbor, ndist);
+                    // Remove an object that's already in there.
+                    // Note that the comparison is based on only the node id,
+                    // and not node id and distance.
+                    nodeq.remove(ndTemp);
+                    // add the current object to the queue.
+                    nodeq.add(ndTemp);
+                }
+            }
+        }
+
+        BroadcastTree ret = new BroadcastTree(nexthoplinks, cost);
+
+        return ret;
+    }
+}
diff --git a/src/main/java/net/sdnlab/common/dijkstra/NodeDist.java b/src/main/java/net/sdnlab/common/dijkstra/NodeDist.java
new file mode 100644
index 00000000..224ad920
--- /dev/null
+++ b/src/main/java/net/sdnlab/common/dijkstra/NodeDist.java
@@ -0,0 +1,56 @@
+package net.sdnlab.common.dijkstra;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+
+
+public class NodeDist implements Comparable<NodeDist> {
+
+        private final DatapathId node;
+        public DatapathId getNode() {
+            return node;
+        }
+
+        private final int dist;
+        public int getDist() {
+            return dist;
+        }
+
+        public NodeDist(DatapathId node, int dist) {
+            this.node = node;
+            this.dist = dist;
+        }
+
+        @Override
+        public int compareTo(NodeDist o) {
+            if (o.dist == this.dist) {
+                return (int)(this.node.getLong() - o.node.getLong());
+            }
+            return this.dist - o.dist;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            NodeDist other = (NodeDist) obj;
+            if (node == null) {
+                if (other.node != null)
+                    return false;
+            } else if (!node.equals(other.node))
+                return false;
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            assert false : "hashCode not designed";
+        return 42;
+        }
+
+ 
+    
+}
diff --git a/src/main/java/net/sdnlab/common/dijkstra/package-info.java b/src/main/java/net/sdnlab/common/dijkstra/package-info.java
new file mode 100644
index 00000000..b042620d
--- /dev/null
+++ b/src/main/java/net/sdnlab/common/dijkstra/package-info.java
@@ -0,0 +1,7 @@
+package net.sdnlab.common.dijkstra;
+
+/**
+ * This package adapts the Dijkara Algorithm provided in TopologyInstance, to use it for own modules
+ * I do not understand, why fundamental algorithms which are useful for everyone are not put in 
+ * a separate library at the first spot....
+ */
diff --git a/src/test/java/net/sdn/ex3/Task32Test.java b/src/test/java/net/sdn/ex3/Task32Test.java
new file mode 100644
index 00000000..8358ca3b
--- /dev/null
+++ b/src/test/java/net/sdn/ex3/Task32Test.java
@@ -0,0 +1,87 @@
+package net.sdn.ex3;
+
+import java.util.HashMap;
+import java.util.HashSet;
+
+import java.util.Set;
+
+import org.junit.Test;
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.OFPort;
+import org.projectfloodlight.openflow.types.U64;
+
+import net.floodlightcontroller.linkdiscovery.Link;
+import net.floodlightcontroller.routing.BroadcastTree;
+import static net.sdnlab.common.dijkstra.Dijkstra.compute;
+public class Task32Test {
+	
+	@Test
+	public void playAroundWithDijkstraTest() {
+		HashMap<DatapathId, Set<Link>> topology = new HashMap<DatapathId, Set<Link>>();
+		DatapathId root = DatapathId.of("0");
+		DatapathId S1 = DatapathId.of("1");
+		DatapathId S2 = DatapathId.of("2");
+		DatapathId S3 = DatapathId.of("3");
+		DatapathId S4 = DatapathId.of("4");
+		DatapathId S5 = DatapathId.of("5");
+		
+		
+		
+		
+		Set<Link> linksroot = new HashSet<Link>();
+		Set<Link> linksS1 = new HashSet<Link>();
+		Set<Link> linksS2 = new HashSet<Link>();
+		Set<Link> linksS3 = new HashSet<Link>();
+		Set<Link> linksS4 = new HashSet<Link>();
+		Set<Link> linksS5 = new HashSet<Link>();
+		
+		
+		Link rootS1 = new Link(root,OFPort.of(1),  S1, OFPort.of(1), U64.of(1) );
+		linksroot.add( rootS1 );
+		
+		Link S1S4 = new Link(S1, OFPort.of(2),  S4, OFPort.of(1), U64.of(1) );
+		Link S1S2 = new Link(S1, OFPort.of(3),  S2, OFPort.of(1), U64.of(1) );
+		linksS1.add( S1S4 );
+		linksS1.add( S1S2 );
+		
+		Link S2S3 = new Link(S2, OFPort.of(2),  S3, OFPort.of(1), U64.of(1) );
+		linksS2.add( S2S3 );
+		
+		Link S4S5 = new Link(S4, OFPort.of(2),  S5, OFPort.of(1), U64.of(1) );
+		linksS4.add( S4S5 );
+		
+		Link S5S3 = new Link(S5, OFPort.of(2),  S3, OFPort.of(2), U64.of(1) );
+		linksS5.add( S5S3  );
+		Link S3S5 = new Link(S3, OFPort.of(2),  S5, OFPort.of(2), U64.of(1) );
+		linksS3.add(  S3S5 );
+		
+		HashMap<Link, Integer> linkCost = new HashMap<Link, Integer>();
+		linkCost.put(rootS1, 1);
+		linkCost.put( S1S4 , 1 );
+		linkCost.put( S1S2 , 10 );
+		
+		linkCost.put( S2S3 , 1 );
+		
+		linkCost.put( S4S5 , 10 );
+		
+		linkCost.put( S5S3 , 1 );
+		
+		linkCost.put( S3S5 , 1 );
+		
+		
+		topology.put(root, linksroot);
+		topology.put(S1, linksS1);
+		topology.put(S2, linksS2);
+		topology.put(S3, linksS3);
+		topology.put(S4, linksS4);
+		topology.put(S5, linksS5);
+		
+		BroadcastTree tree = compute(topology, root, linkCost, false);	
+		for( DatapathId link : tree.getLinks().keySet() ) {
+			System.out.println(tree.getLinks().get(link));
+		}
+	}
+
+
+}
+
-- 
2.17.1


From ce0fce4035de6962f20a309fa4fe3be9f583f0a0 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 14:53:31 +0100
Subject: [PATCH 09/18] [CLEANUP] Add easier example for backtracin

---
 src/test/java/net/sdn/ex3/Task32Test.java | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/test/java/net/sdn/ex3/Task32Test.java b/src/test/java/net/sdn/ex3/Task32Test.java
index 8358ca3b..cb59a456 100644
--- a/src/test/java/net/sdn/ex3/Task32Test.java
+++ b/src/test/java/net/sdn/ex3/Task32Test.java
@@ -77,9 +77,16 @@ public class Task32Test {
 		topology.put(S5, linksS5);
 		
 		BroadcastTree tree = compute(topology, root, linkCost, false);	
-		for( DatapathId link : tree.getLinks().keySet() ) {
-			System.out.println(tree.getLinks().get(link));
+		
+		Link nextLink = null;
+		DatapathId nextNode = S5;
+		while ( nextNode != root ) {
+			System.out.println(nextNode);
+			nextLink = tree.getTreeLink(nextNode);
+			System.out.println(nextLink);
+			nextNode = nextLink.getSrc();
 		}
+		System.out.println(nextNode);
 	}
 
 
-- 
2.17.1


From f5e2a7242620199fd945099c18f03f1af7f25f6a Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 17:03:05 +0100
Subject: [PATCH 10/18] [BUGFIX] TASK31  Wrong entry was stored from a reply
 --> broken cache +add reset for topology change

---
 src/main/java/net/sdnlab/ex3/ARPCache.java   | 16 +++++-
 src/main/java/net/sdnlab/ex3/ARPHandler.java | 14 +++---
 src/main/java/net/sdnlab/ex3/Task31.java     | 51 +++++++++++++-------
 3 files changed, 55 insertions(+), 26 deletions(-)

diff --git a/src/main/java/net/sdnlab/ex3/ARPCache.java b/src/main/java/net/sdnlab/ex3/ARPCache.java
index 2a9446cb..3619e09a 100644
--- a/src/main/java/net/sdnlab/ex3/ARPCache.java
+++ b/src/main/java/net/sdnlab/ex3/ARPCache.java
@@ -4,9 +4,15 @@ import java.util.Map;
 
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.MacAddress;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import net.sdnlab.ex3.ARPEntry;
 public class ARPCache {
+		private static Logger logger;
+		public ARPCache() {
+			logger = LoggerFactory.getLogger(ARPCache.class.getName());
+		}
 		// Use Map instead of Arrays of entries for faster search
 		private static Map<IPv4Address, MacAddress> arpEntries = new HashMap<IPv4Address,MacAddress>();
 		/**
@@ -38,6 +44,7 @@ public class ARPCache {
 		 * @param entry To store
 		 */
 		public synchronized void storeEntry( ARPEntry entry ) {
+			logger.info("Stored " + entry);
 			arpEntries.put(entry.getIpAddress(), entry.getMacAddress());
 		}
 		
@@ -46,11 +53,18 @@ public class ARPCache {
 		 * Can not fail, if Entry does not exist, does nothing.
 		 * @param ipAddress Of the ARPEntry to delete
 		 */
-		public synchronized void deleteEntryByIp( IPv4Address ipAddress ) {
+		public synchronized void deleteEntryByIp( IPv4Address ipAddress ) {		
 			if ( arpEntries.containsKey(ipAddress) ) {
+				logger.info("Delete " + arpEntries.get(ipAddress));
 				arpEntries.remove(ipAddress);
+				
 			}
 		}
 		
+		public synchronized void reset() {
+			logger.info("Reset cache (clear)");
+			arpEntries.clear();
+		}
+		
 		
 }
diff --git a/src/main/java/net/sdnlab/ex3/ARPHandler.java b/src/main/java/net/sdnlab/ex3/ARPHandler.java
index e9c1b2ed..92e3c399 100644
--- a/src/main/java/net/sdnlab/ex3/ARPHandler.java
+++ b/src/main/java/net/sdnlab/ex3/ARPHandler.java
@@ -60,7 +60,9 @@ public class ARPHandler implements IOFMessageListener {
 	private Map <IPv4Address, HostInfo> switches = new HashMap<IPv4Address, HostInfo>();
 	
 	private ARPCache arpCache = new ARPCache();
-	
+	public void resetCache() {
+		this.arpCache.reset();
+	}
 	
 	public ARPHandler( IOFSwitchService switchService) {
 		// fill topology info by hand
@@ -132,13 +134,12 @@ public class ARPHandler implements IOFMessageListener {
 	
 	private void handleARPRequest(IOFSwitch sw, OFMessage msg, FloodlightContext cntx, ARP payload ) {
 		logger.info("Handling ARPRequest from " +  payload.getSenderProtocolAddress() );
-		// first check, if we want to store the sender
+
 		ARPEntry requestSender = ARPEntry.of(payload.getSenderProtocolAddress(), payload.getSenderHardwareAddress());
+		// check if we want to store the request sender
 		if( !arpCache.contains(payload.getSenderProtocolAddress()) ) {
-			
 			arpCache.storeEntry(requestSender);
-			logger.info("Stored " + requestSender );
-		}
+		} 
 		
 		if( arpCache.contains(payload.getTargetProtocolAddress())) {
 			ARPEntry lookedForHost = arpCache.getEntryFromIP(payload.getTargetProtocolAddress());
@@ -218,7 +219,7 @@ public class ARPHandler implements IOFMessageListener {
 	
 	private void handleARPReply(IOFSwitch sw, OFMessage msg, FloodlightContext cnt, ARP payload  ) {
 		if( ! arpCache.contains(payload.getSenderProtocolAddress() )) {
-			arpCache.storeEntry( ARPEntry.of(payload.getSenderProtocolAddress(), payload.getTargetHardwareAddress()));
+			arpCache.storeEntry( ARPEntry.of(payload.getSenderProtocolAddress(), payload.getSenderHardwareAddress()));
 		} 
 		if( arpCache.contains( payload.getTargetProtocolAddress() )) {
 			ARPEntry lookedForHost = arpCache.getEntryFromIP(payload.getSenderProtocolAddress());
@@ -230,5 +231,4 @@ public class ARPHandler implements IOFMessageListener {
 			logger.error("Receiving an ARP Reply to an Request we have not Seen:\n" + payload);
 		}
 	}
-
 }
diff --git a/src/main/java/net/sdnlab/ex3/Task31.java b/src/main/java/net/sdnlab/ex3/Task31.java
index f9900711..2ca3f6ed 100644
--- a/src/main/java/net/sdnlab/ex3/Task31.java
+++ b/src/main/java/net/sdnlab/ex3/Task31.java
@@ -2,6 +2,7 @@ package net.sdnlab.ex3;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.List;
 import java.util.Map;
 
 import org.projectfloodlight.openflow.protocol.OFPortDesc;
@@ -21,7 +22,10 @@ import net.floodlightcontroller.core.module.FloodlightModuleContext;
 import net.floodlightcontroller.core.module.FloodlightModuleException;
 import net.floodlightcontroller.core.module.IFloodlightModule;
 import net.floodlightcontroller.core.module.IFloodlightService;
+import net.floodlightcontroller.linkdiscovery.ILinkDiscovery.LDUpdate;
 import net.floodlightcontroller.threadpool.IThreadPoolService;
+import net.floodlightcontroller.topology.ITopologyListener;
+import net.floodlightcontroller.topology.ITopologyService;
 
 import static net.sdnlab.common.Helper.updateSwitch;
 
@@ -29,6 +33,7 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 	private static Logger logger;
 	private IOFSwitchService switchService;
 	private IFloodlightProviderService floodlightProviderService;
+	private ITopologyService topologyService;
 	private ARPHandler arpHandler;
 	@Override
 	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
@@ -48,7 +53,7 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 					ArrayList<Class<? extends IFloodlightService>>();
 			moduleDependencies.add(IFloodlightProviderService.class);
 			moduleDependencies.add(IOFSwitchService.class);
-			moduleDependencies.add(IThreadPoolService.class);
+			moduleDependencies.add(ITopologyService.class);
 		 return moduleDependencies;
 	}
 
@@ -58,6 +63,16 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 		logger.info("Loaded Module");
 		this.switchService = context.getServiceImpl(IOFSwitchService.class);
 		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
+		this.topologyService = context.getServiceImpl(ITopologyService.class);
+		
+		this.topologyService.addListener( new ITopologyListener() {
+			// We need to reset the cache, if something has changed
+			@Override
+			public void topologyChanged(List<LDUpdate> linkUpdates) {
+				logger.info("Topology changed, reset cache");
+				arpHandler.resetCache();
+			}
+		});
 		this.arpHandler = new ARPHandler( this.switchService );
 	}
 
@@ -90,48 +105,48 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 3);
 			
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.2"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.3"), 4);
 						
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.2"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.3"), 4);
 		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:02") ) ) {
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 4);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 4);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 4);
 			
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 2);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 3);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.2"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.3"), 3);
 					
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 5);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.2"), 5);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.3"), 5);
 		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:03") ) ){
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 1);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 1);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 1);
 			
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.2"), 1);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.3"), 1);
 					
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.2"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.3"), 2);
 		} else if ( switchId.equals(DatapathId.of("00:00:00:00:00:00:00:04") ) ){
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.1"), 4);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.2"), 4);
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.1.3"), 4);
 			
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.1"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.2"), 4);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.2.3"), 4);
 					
 			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 1);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 2);
-			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.1"), 3);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.2"), 2);
+			success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.10.4.3"), 3);
 		}
 		logger.info("Installing config was success: " + success);
 	}
-- 
2.17.1


From 24bf211ef80b083e797267bb17fa9bab9466ee8c Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 17:08:33 +0100
Subject: [PATCH 11/18] [CLEANUP] Change packetinfo to log.debug for cleaner
 console

---
 src/main/java/net/sdnlab/ex3/ARPHandler.java | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/main/java/net/sdnlab/ex3/ARPHandler.java b/src/main/java/net/sdnlab/ex3/ARPHandler.java
index 92e3c399..70af4591 100644
--- a/src/main/java/net/sdnlab/ex3/ARPHandler.java
+++ b/src/main/java/net/sdnlab/ex3/ARPHandler.java
@@ -146,12 +146,14 @@ public class ARPHandler implements IOFMessageListener {
 			ARPEntry destination = requestSender;
 			Ethernet packetToInject = createARPPacket( lookedForHost, destination, ArpOpcode.REPLY);
 			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
-			logger.info("Inject reply\n----------" + packetToInject  + "\n----------was success " + success );
+			logger.info("Inject reply::was success " + success );
+			logger.debug("Injected Packet: " + packetToInject);
 		} else {
 			ARPEntry destination = ARPEntry.of( payload.getTargetProtocolAddress(), MacAddress.of("FF:FF:FF:FF:FF:FF"));
 			Ethernet packetToInject = createARPPacket(requestSender, destination, ArpOpcode.REQUEST);
 			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
-			logger.info("Inject request\n--------------" + packetToInject  + "\n-----------\nwas success " + success );
+			logger.info("Inject request::was success " + success );
+			logger.debug("Injected Packet: " + packetToInject);
 		}
 	}
 	
@@ -226,7 +228,8 @@ public class ARPHandler implements IOFMessageListener {
 			ARPEntry destination = arpCache.getEntryFromIP(payload.getTargetProtocolAddress() );
 			Ethernet packetToInject = createARPPacket( lookedForHost, destination, ArpOpcode.REPLY);
 			boolean success = injectPacketForHost(destination.getIpAddress(), packetToInject);
-			logger.info("Inject reply\n----------" + packetToInject  + "\n----------\nwas success " + success );
+			logger.info("Inject reply::was success " + success );
+			logger.debug("Injected Packet: " + packetToInject);
 		} else {
 			logger.error("Receiving an ARP Reply to an Request we have not Seen:\n" + payload);
 		}
-- 
2.17.1


From 4caf8d3f662b8d82adb075b5a9143d334514acfe Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 18:04:48 +0100
Subject: [PATCH 12/18] [TASK32] Setup + Static Flows

Static Flows for h1,h2,h3,h4,h5,h6,h7,h8 are pushed
---
 src/main/java/net/sdnlab/common/Helper.java   |   9 +-
 .../net/sdnlab/common/dijkstra/Dijkstra.java  |   2 +-
 src/main/java/net/sdnlab/ex3/ARPHandler.java  |   1 +
 src/main/java/net/sdnlab/ex3/Task32.java      |  60 ++++++++
 .../net/sdnlab/ex3/Task32StaticFlows.java     | 135 ++++++++++++++++++
 ...htcontroller.core.module.IFloodlightModule |   1 +
 src/main/resources/task32.properties          |  76 ++++++++++
 src/test/java/net/sdn/ex3/Task32Test.java     |   5 +-
 8 files changed, 277 insertions(+), 12 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/Task32.java
 create mode 100644 src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
 create mode 100644 src/main/resources/task32.properties

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
index 3d302912..3d05e9b1 100644
--- a/src/main/java/net/sdnlab/common/Helper.java
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -1,10 +1,6 @@
 package net.sdnlab.common;
 
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.PriorityQueue;
-import java.util.Set;
 
 import org.projectfloodlight.openflow.protocol.OFFactory;
 import org.projectfloodlight.openflow.protocol.OFFlowAdd;
@@ -12,15 +8,14 @@ import org.projectfloodlight.openflow.protocol.action.OFAction;
 import org.projectfloodlight.openflow.protocol.action.OFActions;
 import org.projectfloodlight.openflow.protocol.match.Match;
 import org.projectfloodlight.openflow.protocol.match.MatchField;
-import org.projectfloodlight.openflow.types.DatapathId;
+
 import org.projectfloodlight.openflow.types.EthType;
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.OFPort;
 import org.projectfloodlight.openflow.types.U64;
 
 import net.floodlightcontroller.core.IOFSwitch;
-import net.floodlightcontroller.linkdiscovery.Link;
-import net.floodlightcontroller.routing.BroadcastTree;
+
 
 
 /**
diff --git a/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
index f22cc305..48c2e61c 100644
--- a/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
+++ b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
@@ -16,7 +16,7 @@ public class Dijkstra {
 	/*
      * Dijkstra that calculates destination rooted trees over the entire topology.
      */
-	private static final Logger log = LoggerFactory.getLogger(Dijkstra.class.getName());
+	private static final Logger log = LoggerFactory.getLogger(Dijkstra.class);
     public static final int MAX_LINK_WEIGHT = 10000;
     public static final int MAX_PATH_WEIGHT = Integer.MAX_VALUE - MAX_LINK_WEIGHT - 1;
     public static BroadcastTree compute(Map<DatapathId, Set<Link>> links, DatapathId root,
diff --git a/src/main/java/net/sdnlab/ex3/ARPHandler.java b/src/main/java/net/sdnlab/ex3/ARPHandler.java
index 70af4591..89261375 100644
--- a/src/main/java/net/sdnlab/ex3/ARPHandler.java
+++ b/src/main/java/net/sdnlab/ex3/ARPHandler.java
@@ -47,6 +47,7 @@ public class ARPHandler implements IOFMessageListener {
 		private DatapathId switchId;
 		private int outPutPort;
 		
+		@SuppressWarnings("unused")
 		public DatapathId getSwitchId() {
 			return switchId;
 		}
diff --git a/src/main/java/net/sdnlab/ex3/Task32.java b/src/main/java/net/sdnlab/ex3/Task32.java
new file mode 100644
index 00000000..f338d199
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/Task32.java
@@ -0,0 +1,60 @@
+package net.sdnlab.ex3;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.core.module.FloodlightModuleContext;
+import net.floodlightcontroller.core.module.FloodlightModuleException;
+import net.floodlightcontroller.core.module.IFloodlightModule;
+import net.floodlightcontroller.core.module.IFloodlightService;
+import net.floodlightcontroller.topology.ITopologyService;
+
+public class Task32 implements IFloodlightModule {
+	private static Logger logger;
+	private IOFSwitchService switchService;
+	private IFloodlightProviderService floodlightProviderService;
+	private ITopologyService topologyService;
+	private Task32StaticFlows staticFlows;
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
+		Collection<Class<? extends IFloodlightService>> moduleDependencies = new
+				ArrayList<Class<? extends IFloodlightService>>();
+		moduleDependencies.add(IFloodlightProviderService.class);
+		moduleDependencies.add(IOFSwitchService.class);
+		moduleDependencies.add(ITopologyService.class);
+	 return moduleDependencies;
+	}
+
+	@Override
+	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
+		this.logger = LoggerFactory.getLogger(Task32.class);
+		this.switchService = context.getServiceImpl(IOFSwitchService.class);
+		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
+		this.topologyService = context.getServiceImpl(ITopologyService.class);
+	}
+
+	@Override
+	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		logger.info("Module Task32 loaded");
+		this.staticFlows = new Task32StaticFlows(this.switchService);
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java b/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
new file mode 100644
index 00000000..ed6cd0c6
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
@@ -0,0 +1,135 @@
+package net.sdnlab.ex3;
+
+import static net.sdnlab.common.Helper.updateSwitch;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.projectfloodlight.openflow.protocol.OFPortDesc;
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.IOFSwitchListener;
+import net.floodlightcontroller.core.PortChangeType;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+/**
+ * Push static flows
+ * @author fabian
+ *
+ */
+public class Task32StaticFlows implements IOFSwitchListener {
+	// We need to update several switches,
+	// use a poor mans variant of a command pattern
+	private abstract class SwitchUpdate {
+		// We need to pass a reference, because 
+		// we have no reference to the switch, when we update it
+		abstract boolean update(IOFSwitch switchToUpdate);
+	}
+	
+	// store updates to perform
+	private Map<DatapathId,SwitchUpdate> staticFlows;
+	
+	// We need the switch service
+	IOFSwitchService switchService;
+	
+	private Logger logger;
+	
+	public Task32StaticFlows(IOFSwitchService switchService ) {
+		this.logger = LoggerFactory.getLogger(Task32StaticFlows.class);
+		staticFlows = new HashMap<DatapathId, SwitchUpdate>();
+		
+		this.switchService = switchService;
+		// now fill it up:
+		
+		// Switch 1.1 with the connected hosts
+		staticFlows.put(DatapathId.of("00:00:00:00:00:00:01:01"), new SwitchUpdate() {
+			@Override
+			boolean update(IOFSwitch switchToUpdate) {
+				boolean success = true;
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.1"), 3);
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.2"), 4);
+				return false;
+			}
+		});
+		
+		// switch 1.2
+		staticFlows.put(DatapathId.of("00:00:00:00:00:00:01:02"), new SwitchUpdate() {
+			@Override
+			boolean update(IOFSwitch switchToUpdate) {
+				boolean success = true;
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.3"), 3);
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.4"), 4);
+				return false;
+			}
+		});
+		
+		// switch 2.1
+		staticFlows.put(DatapathId.of("00:00:00:00:00:00:02:01"), new SwitchUpdate() {
+			@Override
+			boolean update(IOFSwitch switchToUpdate) {
+				boolean success = true;
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.1"), 3);
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.2"), 4);
+				return false;
+			}
+		});
+		
+		// switch 2.2
+		staticFlows.put(DatapathId.of("00:00:00:00:00:00:02:02"), new SwitchUpdate() {
+			@Override
+			boolean update(IOFSwitch switchToUpdate) {
+				boolean success = true;
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.3"), 3);
+				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.4"), 4);
+				return false;
+			}
+		});
+		
+		this.switchService.addOFSwitchListener(this);
+	}
+	@Override
+	public void switchAdded(DatapathId switchId) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void switchRemoved(DatapathId switchId) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void switchActivated(DatapathId switchId) {
+		// If we have a static flow for this one, push it now
+		if( staticFlows.containsKey(switchId) ) {
+			logger.info("Pushing static flow to: " + switchId );
+			IOFSwitch switchToUse = switchService.getSwitch(switchId);
+			boolean success = staticFlows.get(switchId).update(switchToUse);
+			logger.info("Success: " + success);
+		}
+
+	}
+
+	@Override
+	public void switchPortChanged(DatapathId switchId, OFPortDesc port, PortChangeType type) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void switchChanged(DatapathId switchId) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void switchDeactivated(DatapathId switchId) {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
index 0340c080..fb43c3e2 100644
--- a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
+++ b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
@@ -32,3 +32,4 @@ net.floodlightcontroller.cpanalyzer.CPAnalyzer
 net.floodlightcontroller.hasupport.HAController
 net.sdnlab.ex2.Task23
 net.sdnlab.ex3.Task31
+net.sdnlab.ex3.Task32
\ No newline at end of file
diff --git a/src/main/resources/task32.properties b/src/main/resources/task32.properties
new file mode 100644
index 00000000..463c152e
--- /dev/null
+++ b/src/main/resources/task32.properties
@@ -0,0 +1,76 @@
+floodlight.modules=\
+net.floodlightcontroller.jython.JythonDebugInterface,\
+net.floodlightcontroller.storage.memory.MemoryStorageSource,\
+net.floodlightcontroller.core.internal.FloodlightProvider,\
+net.floodlightcontroller.threadpool.ThreadPool,\
+net.floodlightcontroller.debugcounter.DebugCounterServiceImpl,\
+net.floodlightcontroller.perfmon.PktInProcessingTime,\
+net.floodlightcontroller.staticentry.StaticEntryPusher,\
+net.floodlightcontroller.restserver.RestApiServer,\
+net.floodlightcontroller.topology.TopologyManager,\
+net.floodlightcontroller.routing.RoutingManager,\
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager,\
+net.floodlightcontroller.ui.web.StaticWebRoutable,\
+net.floodlightcontroller.loadbalancer.LoadBalancer,\
+net.floodlightcontroller.firewall.Firewall,\
+net.floodlightcontroller.dhcpserver.DHCPServer,\
+net.floodlightcontroller.simpleft.FT,\
+net.floodlightcontroller.devicemanager.internal.DeviceManagerImpl,\
+net.floodlightcontroller.accesscontrollist.ACL,\
+net.floodlightcontroller.statistics.StatisticsCollector,\
+net.floodlightcontroller.hasupport.HAController, \
+net.sdnlab.ex3.Task32
+org.sdnplatform.sync.internal.SyncManager.authScheme=CHALLENGE_RESPONSE
+org.sdnplatform.sync.internal.SyncManager.keyStorePath=/etc/floodlight/myKey.jceks
+org.sdnplatform.sync.internal.SyncManager.dbPath=/var/lib/floodlight/
+org.sdnplatform.sync.internal.SyncManager.keyStorePassword=syncPass
+org.sdnplatform.sync.internal.SyncManager.port=6642
+org.sdnplatform.sync.internal.SyncManager.thisNodeId=1
+org.sdnplatform.sync.internal.SyncManager.persistenceEnabled=FALSE
+org.sdnplatform.sync.internal.SyncManager.nodes=[\
+{"nodeId": 1, "domainId": 1, "hostname": "192.168.56.1", "port": 6642},\
+{"nodeId": 2, "domainId": 1, "hostname": "192.168.56.1", "port": 6643},\
+{"nodeId": 3, "domainId": 1, "hostname": "192.168.56.1", "port": 6644},\
+{"nodeId": 4, "domainId": 1, "hostname": "192.168.56.1", "port": 6645}\
+]
+net.floodlightcontroller.forwarding.Forwarding.match=in-port, vlan, mac, ip, transport, flag
+net.floodlightcontroller.forwarding.Forwarding.detailed-match=src-mac, dst-mac, src-ip, dst-ip, src-transport, dst-transport
+net.floodlightcontroller.forwarding.Forwarding.flood-arp=NO
+net.floodlightcontroller.forwarding.Forwarding.idle-timeout=5
+net.floodlightcontroller.forwarding.Forwarding.set-send-flow-rem-flag=FALSE
+net.floodlightcontroller.forwarding.Forwarding.remove-flows-on-link-or-port-down=TRUE
+net.floodlightcontroller.core.internal.FloodlightProvider.openFlowPort=6653
+net.floodlightcontroller.core.internal.FloodlightProvider.role=ACTIVE
+net.floodlightcontroller.core.internal.FloodlightProvider.controllerId=1
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-history-size=10
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-update-threshold=0.5
+net.floodlightcontroller.core.internal.FloodlightProvider.shutdownOnTransitionToStandby=true
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowPort=6653
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowAddresses=0.0.0.0
+net.floodlightcontroller.core.internal.OFSwitchManager.workerThreads=16
+net.floodlightcontroller.core.internal.OFSwitchManager.bossThreads=1
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionBacklog=1000
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionTimeoutMs=60000
+net.floodlightcontroller.core.internal.OFSwitchManager.defaultMaxTablesToReceiveTableMissFlow=1
+net.floodlightcontroller.core.internal.OFSwitchManager.maxTablesToReceiveTableMissFlowPerDpid={"00:00:00:00:00:00:00:01":"1","2":"1"}
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnInitialHandshakeAsMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnEachTransitionToMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePath=/path/to.jecks
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePassword=PassFL
+net.floodlightcontroller.core.internal.OFSwitchManager.useSsl=NO
+net.floodlightcontroller.core.internal.OFSwitchManager.supportedOpenFlowVersions=1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+net.floodlightcontroller.core.internal.OFSwitchManager.switchesInitialState={"00:00:00:00:00:00:00:01":"ROLE_MASTER","00:00:00:00:00:00:00:02":"ROLE_MASTER", "00:00:00:00:00:00:00:03":"ROLE_MASTER", "00:00:00:00:00:00:00:04":"ROLE_MASTER","00:00:00:00:00:00:00:05":"ROLE_MASTER","00:00:00:00:00:00:00:06":"ROLE_MASTER","00:00:00:00:00:00:00:07":"ROLE_MASTER","00:00:00:00:00:00:00:08":"ROLE_MASTER"}
+net.floodlightcontroller.restserver.RestApiServer.keyStorePath=/path/to.jceks
+net.floodlightcontroller.restserver.RestApiServer.keyStorePassword=Password
+net.floodlightcontroller.restserver.RestApiServer.httpsNeedClientAuthentication=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttps=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttp=YES
+net.floodlightcontroller.restserver.RestApiServer.httpsPort=8081
+net.floodlightcontroller.restserver.RestApiServer.httpPort=8080
+net.floodlightcontroller.restserver.RestApiServer.accessControlAllowAllOrigins=TRUE
+net.floodlightcontroller.statistics.StatisticsCollector.enable=FALSE
+net.floodlightcontroller.statistics.StatisticsCollector.collectionIntervalPortStatsSeconds=10
+net.floodlightcontroller.topology.TopologyManager.pathMetric=latency
+net.floodlightcontroller.topology.TopologyManager.maxPathsToCompute=3
+net.floodlightcontroller.hasupport.HAController.nodeid=1
+net.floodlightcontroller.hasupport.HAController.serverPort=127.0.0.1:4242
diff --git a/src/test/java/net/sdn/ex3/Task32Test.java b/src/test/java/net/sdn/ex3/Task32Test.java
index cb59a456..0d197447 100644
--- a/src/test/java/net/sdn/ex3/Task32Test.java
+++ b/src/test/java/net/sdn/ex3/Task32Test.java
@@ -24,10 +24,7 @@ public class Task32Test {
 		DatapathId S3 = DatapathId.of("3");
 		DatapathId S4 = DatapathId.of("4");
 		DatapathId S5 = DatapathId.of("5");
-		
-		
-		
-		
+			
 		Set<Link> linksroot = new HashSet<Link>();
 		Set<Link> linksS1 = new HashSet<Link>();
 		Set<Link> linksS2 = new HashSet<Link>();
-- 
2.17.1


From 5e0ebbd4a4471803c6bf96de4e535ed781ec55e4 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 3 Dec 2018 21:01:57 +0100
Subject: [PATCH 13/18] [TASK32] Solution

+needs some cleanup, but not today
---
 src/main/java/net/sdnlab/common/Helper.java   |   9 +-
 .../net/sdnlab/common/dijkstra/Dijkstra.java  |   2 +-
 .../net/sdnlab/ex3/ReactiveRoutingModule.java | 194 ++++++++++++++++++
 src/main/java/net/sdnlab/ex3/Task32.java      |   7 +-
 .../net/sdnlab/ex3/Task32StaticFlows.java     |  13 +-
 5 files changed, 214 insertions(+), 11 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java

diff --git a/src/main/java/net/sdnlab/common/Helper.java b/src/main/java/net/sdnlab/common/Helper.java
index 3d05e9b1..8c55fa9c 100644
--- a/src/main/java/net/sdnlab/common/Helper.java
+++ b/src/main/java/net/sdnlab/common/Helper.java
@@ -30,10 +30,14 @@ public class Helper{
 	}*/ 
 	
 	public static boolean updateSwitch (IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort) {
-		return updateSwitch( switchToUpdate, ipToMatch, outputPort, U64.of(0xcafe), 32700);
+		return updateSwitch( switchToUpdate, ipToMatch, outputPort, U64.of(0xcafe), 32700, 0);
 	}
 	
-	public static boolean updateSwitch(IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort, U64 flowNumber, int flowPriority) {	
+	public static boolean updateSwitch (IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort,  int idleTimeout ) {
+		return updateSwitch(switchToUpdate, ipToMatch, outputPort, U64.of(0xcafe), 32700, idleTimeout );
+	}
+	
+	public static boolean updateSwitch(IOFSwitch switchToUpdate, IPv4Address ipToMatch,int outputPort, U64 flowNumber, int flowPriority, int idleTimeout) {	
 		// we want to use a factory, definitely matching to the switch
 		// so instead of using generic factory with version, we 
 		// always use the factory provided by the switch
@@ -59,6 +63,7 @@ public class Helper{
 		OFFlowAdd flowAdd = factoryToUse.buildFlowAdd()
 				.setCookie(flowNumber)
 				.setPriority(flowPriority)
+				.setIdleTimeout(idleTimeout)
 				.setMatch(match)
 				.setActions(actionList)
 				.build();
diff --git a/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
index 48c2e61c..1d0ef989 100644
--- a/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
+++ b/src/main/java/net/sdnlab/common/dijkstra/Dijkstra.java
@@ -19,6 +19,7 @@ public class Dijkstra {
 	private static final Logger log = LoggerFactory.getLogger(Dijkstra.class);
     public static final int MAX_LINK_WEIGHT = 10000;
     public static final int MAX_PATH_WEIGHT = Integer.MAX_VALUE - MAX_LINK_WEIGHT - 1;
+    
     public static BroadcastTree compute(Map<DatapathId, Set<Link>> links, DatapathId root,
             Map<Link, Integer> linkCost,
             boolean isDstRooted) {
@@ -38,7 +39,6 @@ public class Dijkstra {
         cost.put(root, 0);
 
         //log.debug("{}", links);
-
         while (nodeq.peek() != null) {
             NodeDist n = nodeq.poll();
             DatapathId cnode = n.getNode();
diff --git a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
new file mode 100644
index 00000000..197a58dd
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
@@ -0,0 +1,194 @@
+package net.sdnlab.ex3;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFMessage;
+import org.projectfloodlight.openflow.protocol.OFPacketOut;
+import org.projectfloodlight.openflow.protocol.OFType;
+import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.OFPort;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.FloodlightContext;
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.IOFMessageListener;
+import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.linkdiscovery.Link;
+import net.floodlightcontroller.core.IListener.Command;
+import net.floodlightcontroller.packet.Ethernet;
+import net.floodlightcontroller.packet.IPv4;
+import net.floodlightcontroller.routing.BroadcastTree;
+import net.floodlightcontroller.topology.ITopologyListener;
+import net.floodlightcontroller.topology.ITopologyService;
+import net.sdnlab.common.dijkstra.Dijkstra;
+
+
+import static net.sdnlab.common.Helper.updateSwitch;
+public class ReactiveRoutingModule implements IOFMessageListener {
+
+	private Logger log;
+	// Store Edgeswitches associated with an IP Address in a covinient Map
+	private Map<IPv4Address, DatapathId> edgeSwitches;
+	private ITopologyService topologyService;
+	private IOFSwitchService switchService;
+	
+	private class SourceDestination {
+		// source of the packet in question
+		public IPv4Address source;
+		// destination of the packet in question
+		public IPv4Address destination;
+		
+		@Override
+		public String toString() {
+			return "[Source: " + source + ", Destination: " + destination +"]";
+		}
+	}
+	
+	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService ) {
+		this.topologyService = topologyService;
+		this.switchService = switchService;
+		log= LoggerFactory.getLogger( ReactiveRoutingModule.class );
+		// Fill map of edge Switches (leaf nodes of tree)
+		edgeSwitches = new HashMap<IPv4Address, DatapathId>();
+		DatapathId switch11 = DatapathId.of("00:00:00:00:00:00:01:01");
+		DatapathId switch12 = DatapathId.of("00:00:00:00:00:00:01:02");
+		DatapathId switch21 = DatapathId.of("00:00:00:00:00:00:02:01");
+		DatapathId switch22 = DatapathId.of("00:00:00:00:00:00:02:02");
+		
+		// Switch 1.1
+		edgeSwitches.put(IPv4Address.of("10.0.1.1"), switch11 );
+		edgeSwitches.put(IPv4Address.of("10.0.1.2"), switch11 );
+		
+		// Switch 1.2
+		edgeSwitches.put(IPv4Address.of("10.0.1.3"), switch12 );
+		edgeSwitches.put(IPv4Address.of("10.0.1.4"), switch12 );
+		
+		// Switch 2.1
+		edgeSwitches.put(IPv4Address.of("10.0.2.1"), switch21 );
+		edgeSwitches.put(IPv4Address.of("10.0.2.2"), switch21 );
+		
+		// Switch 2.2
+		edgeSwitches.put(IPv4Address.of("10.0.2.3"), switch22 );
+		edgeSwitches.put(IPv4Address.of("10.0.2.4"), switch22 );	
+	}
+	
+	@Override
+	public String getName() {
+		return this.getClass().getName();
+	}
+
+	@Override
+	public boolean isCallbackOrderingPrereq(OFType type, String name) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isCallbackOrderingPostreq(OFType type, String name) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
+		// check if we have a packet of the right type	
+		Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);
+ 
+		if( eth.getEtherType().equals(EthType.IPv4)) {	
+			IPv4 payload = (IPv4) eth.getPayload();
+			SourceDestination sourceDestination = getSourceDestination(payload);
+			
+			if( ! checkIfValid( sourceDestination )) {
+				// Maybe someone else is interrested....
+				return Command.CONTINUE;
+			}
+			
+			computeRoute(sourceDestination);
+			injectPacketForHost(sourceDestination.destination, eth);
+			return Command.STOP;
+		} else {
+			return Command.CONTINUE;
+		}	
+	}
+	
+	// we only want to compute routes for edge links we know
+	private boolean checkIfValid(SourceDestination sourceDestination ) {
+		if (edgeSwitches.containsKey(sourceDestination.destination)  
+				&& edgeSwitches.containsKey(sourceDestination.source) ){
+			return true;
+		} else {
+			log.info("Got invalid SourceDestination pair: " + sourceDestination );
+			return false;
+		}
+	}
+	
+	private void computeRoute(SourceDestination sourceDestination ) {
+		log.info("Computing route: " + sourceDestination);
+		DatapathId rootNode = edgeSwitches.get(sourceDestination.source);
+		DatapathId destinationNode = edgeSwitches.get(sourceDestination.destination);
+		Map<DatapathId, Set<Link>> allLinks = this.topologyService.getAllLinks();
+		
+		BroadcastTree broadCastTree = Dijkstra.compute(allLinks, rootNode, null, false);
+		
+		 
+		Link nextLink = null;
+		DatapathId nextNode = destinationNode;
+		while ( ! nextNode.equals(rootNode) ) {
+			System.out.println(nextNode);
+			nextLink = broadCastTree.getTreeLink(nextNode);
+			System.out.println(nextLink);
+			nextNode = nextLink.getSrc();
+			
+			OFPort outputPort = nextLink.getSrcPort();
+			IOFSwitch switchToUpdate = this.switchService.getSwitch(nextNode);
+			updateSwitch(switchToUpdate, sourceDestination.destination, outputPort.getPortNumber(), 5 );
+			
+		}
+		System.out.println(nextNode);
+	}
+
+	private SourceDestination getSourceDestination(IPv4 payload) {	
+			SourceDestination sourceDestination = new SourceDestination();
+			sourceDestination.source = payload.getSourceAddress();
+			sourceDestination.destination = payload.getDestinationAddress();
+		return sourceDestination;
+	}
+	
+	private boolean injectPacketForHost(IPv4Address hostAddr, Ethernet packet) {
+		// First find out on which switch and port to inject
+		DatapathId id  = edgeSwitches.get(hostAddr );
+		if( id == null) {
+			log.info("Could not find a switch for host" + hostAddr);
+			return false;
+		}
+		// get the attached switch and outputport
+		IOFSwitch switchToUse = this.switchService.getSwitch(id);
+
+		
+		//now we can serialize the packet again, and send it to the second switch
+		byte[] serializedPacket= packet.serialize();
+		OFFactory switchFactory = switchToUse.getOFFactory();
+		
+
+		List<OFAction> actions = Collections.singletonList(
+							(OFAction)switchFactory.actions().output(OFPort.TABLE, 0xffFFffFF) );
+		OFPacketOut po = switchFactory.buildPacketOut()
+				.setData(serializedPacket)
+				.setInPort(OFPort.CONTROLLER)
+				.setActions(actions)
+				.build();
+		// finally write to output
+		return switchToUse.write(po);
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex3/Task32.java b/src/main/java/net/sdnlab/ex3/Task32.java
index f338d199..6c2f2fe4 100644
--- a/src/main/java/net/sdnlab/ex3/Task32.java
+++ b/src/main/java/net/sdnlab/ex3/Task32.java
@@ -4,6 +4,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Map;
 
+import org.projectfloodlight.openflow.protocol.OFType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -16,11 +17,12 @@ import net.floodlightcontroller.core.module.IFloodlightService;
 import net.floodlightcontroller.topology.ITopologyService;
 
 public class Task32 implements IFloodlightModule {
-	private static Logger logger;
+	private Logger logger;
 	private IOFSwitchService switchService;
 	private IFloodlightProviderService floodlightProviderService;
 	private ITopologyService topologyService;
 	private Task32StaticFlows staticFlows;
+	private ReactiveRoutingModule reactiveRouting;
 	@Override
 	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
 		// TODO Auto-generated method stub
@@ -49,12 +51,15 @@ public class Task32 implements IFloodlightModule {
 		this.switchService = context.getServiceImpl(IOFSwitchService.class);
 		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
 		this.topologyService = context.getServiceImpl(ITopologyService.class);
+		this.reactiveRouting = new ReactiveRoutingModule(this.topologyService, this.switchService);
 	}
 
 	@Override
 	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
 		logger.info("Module Task32 loaded");
 		this.staticFlows = new Task32StaticFlows(this.switchService);
+		
+		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.reactiveRouting);
 	}
 
 }
diff --git a/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java b/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
index ed6cd0c6..07962f81 100644
--- a/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
+++ b/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
@@ -51,7 +51,7 @@ public class Task32StaticFlows implements IOFSwitchListener {
 				boolean success = true;
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.1"), 3);
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.2"), 4);
-				return false;
+				return success;
 			}
 		});
 		
@@ -62,7 +62,7 @@ public class Task32StaticFlows implements IOFSwitchListener {
 				boolean success = true;
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.3"), 3);
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.1.4"), 4);
-				return false;
+				return success;
 			}
 		});
 		
@@ -73,7 +73,7 @@ public class Task32StaticFlows implements IOFSwitchListener {
 				boolean success = true;
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.1"), 3);
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.2"), 4);
-				return false;
+				return success;
 			}
 		});
 		
@@ -84,7 +84,7 @@ public class Task32StaticFlows implements IOFSwitchListener {
 				boolean success = true;
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.3"), 3);
 				success  = success && updateSwitch( switchToUpdate, IPv4Address.of("10.0.2.4"), 4);
-				return false;
+				return success;
 			}
 		});
 		
@@ -92,14 +92,12 @@ public class Task32StaticFlows implements IOFSwitchListener {
 	}
 	@Override
 	public void switchAdded(DatapathId switchId) {
-		// TODO Auto-generated method stub
 
 	}
 
 	@Override
 	public void switchRemoved(DatapathId switchId) {
-		// TODO Auto-generated method stub
-
+		// we don't care
 	}
 
 	@Override
@@ -110,6 +108,7 @@ public class Task32StaticFlows implements IOFSwitchListener {
 			IOFSwitch switchToUse = switchService.getSwitch(switchId);
 			boolean success = staticFlows.get(switchId).update(switchToUse);
 			logger.info("Success: " + success);
+			
 		}
 
 	}
-- 
2.17.1


From 99bd76ca10b26986c2e67a8a0c9992a008d0e041 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Tue, 4 Dec 2018 10:58:29 +0100
Subject: [PATCH 14/18] [CLEANUP] Rename Task32Static Flows to Task3x...

these static flow entries are the same for both sub tasks
---
 src/main/java/net/sdnlab/ex3/Task32.java                    | 4 ++--
 .../ex3/{Task32StaticFlows.java => Task3xStaticFlows.java}  | 6 +++---
 2 files changed, 5 insertions(+), 5 deletions(-)
 rename src/main/java/net/sdnlab/ex3/{Task32StaticFlows.java => Task3xStaticFlows.java} (95%)

diff --git a/src/main/java/net/sdnlab/ex3/Task32.java b/src/main/java/net/sdnlab/ex3/Task32.java
index 6c2f2fe4..2a1b4385 100644
--- a/src/main/java/net/sdnlab/ex3/Task32.java
+++ b/src/main/java/net/sdnlab/ex3/Task32.java
@@ -21,7 +21,7 @@ public class Task32 implements IFloodlightModule {
 	private IOFSwitchService switchService;
 	private IFloodlightProviderService floodlightProviderService;
 	private ITopologyService topologyService;
-	private Task32StaticFlows staticFlows;
+	private Task3xStaticFlows staticFlows;
 	private ReactiveRoutingModule reactiveRouting;
 	@Override
 	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
@@ -57,7 +57,7 @@ public class Task32 implements IFloodlightModule {
 	@Override
 	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
 		logger.info("Module Task32 loaded");
-		this.staticFlows = new Task32StaticFlows(this.switchService);
+		this.staticFlows = new Task3xStaticFlows(this.switchService);
 		
 		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.reactiveRouting);
 	}
diff --git a/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
similarity index 95%
rename from src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
rename to src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
index 07962f81..66c139bf 100644
--- a/src/main/java/net/sdnlab/ex3/Task32StaticFlows.java
+++ b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
@@ -20,7 +20,7 @@ import net.floodlightcontroller.core.internal.IOFSwitchService;
  * @author fabian
  *
  */
-public class Task32StaticFlows implements IOFSwitchListener {
+public class Task3xStaticFlows implements IOFSwitchListener {
 	// We need to update several switches,
 	// use a poor mans variant of a command pattern
 	private abstract class SwitchUpdate {
@@ -37,8 +37,8 @@ public class Task32StaticFlows implements IOFSwitchListener {
 	
 	private Logger logger;
 	
-	public Task32StaticFlows(IOFSwitchService switchService ) {
-		this.logger = LoggerFactory.getLogger(Task32StaticFlows.class);
+	public Task3xStaticFlows(IOFSwitchService switchService ) {
+		this.logger = LoggerFactory.getLogger(Task3xStaticFlows.class);
 		staticFlows = new HashMap<DatapathId, SwitchUpdate>();
 		
 		this.switchService = switchService;
-- 
2.17.1


From 6e38be7d026acfacaa1b1f54ebf94c0ec6656c2d Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Tue, 4 Dec 2018 12:00:20 +0100
Subject: [PATCH 15/18] [CLEANUP] Some Cleanup and the introduction of a cost
 module for proceeding to task33

---
 .../net/sdnlab/ex3/ILinkCostCalculator.java   | 19 +++++
 .../net/sdnlab/ex3/ReactiveRoutingModule.java | 80 +++++++++++++++----
 src/main/java/net/sdnlab/ex3/Task32.java      |  3 +-
 .../sdnlab/ex3/Task32LinkCostCalculator.java  | 32 ++++++++
 .../net/sdnlab/ex3/Task3xStaticFlows.java     |  1 -
 5 files changed, 118 insertions(+), 17 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
 create mode 100644 src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java

diff --git a/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java b/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
new file mode 100644
index 00000000..c635ec88
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
@@ -0,0 +1,19 @@
+package net.sdnlab.ex3;
+
+import java.util.Map;
+import java.util.Set;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+
+import net.floodlightcontroller.linkdiscovery.Link;
+
+public interface ILinkCostCalculator {
+
+	/**
+	 * 
+	 * @param allLinks where we are interested in the weights
+	 * @returs a map with a weight for each link
+	 */
+	Map<Link, Integer> calculateLinkCost(Map<DatapathId, Set<Link>> allLinks);
+	
+}
diff --git a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
index 197a58dd..f2d8ea67 100644
--- a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
+++ b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
@@ -41,7 +41,8 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 	private Map<IPv4Address, DatapathId> edgeSwitches;
 	private ITopologyService topologyService;
 	private IOFSwitchService switchService;
-	
+	private ILinkCostCalculator linkCostCalculator;
+	private int flowTimeOutInSeconds = 5;
 	private class SourceDestination {
 		// source of the packet in question
 		public IPv4Address source;
@@ -54,9 +55,15 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		}
 	}
 	
-	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService ) {
+	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator) {
+		this ( topologyService, switchService, linkCostCalculator, 5);
+	}
+	
+	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator, int flowTimeOutInSeconds ) {
 		this.topologyService = topologyService;
 		this.switchService = switchService;
+		this.linkCostCalculator = linkCostCalculator;
+		this.flowTimeOutInSeconds = flowTimeOutInSeconds;
 		log= LoggerFactory.getLogger( ReactiveRoutingModule.class );
 		// Fill map of edge Switches (leaf nodes of tree)
 		edgeSwitches = new HashMap<IPv4Address, DatapathId>();
@@ -113,8 +120,21 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 				return Command.CONTINUE;
 			}
 			
-			computeRoute(sourceDestination);
-			injectPacketForHost(sourceDestination.destination, eth);
+			BroadcastTree route = computeRoute(sourceDestination);
+			
+			boolean routeIsInstalled = installRoute(route, sourceDestination);
+			boolean packetIsInjected = false;
+			
+			if(routeIsInstalled) {
+				packetIsInjected = injectPacketForHost(sourceDestination.destination, eth);
+			}
+			
+			if( routeIsInstalled && packetIsInjected ) {
+				log.info("succesflly handled " + sourceDestination );
+			} else {
+				log.error("failed to handle " + sourceDestination + "route:" + routeIsInstalled +" packetinjectked:" + packetIsInjected);
+			}
+			
 			return Command.STOP;
 		} else {
 			return Command.CONTINUE;
@@ -132,29 +152,59 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		}
 	}
 	
-	private void computeRoute(SourceDestination sourceDestination ) {
+	private BroadcastTree computeRoute(SourceDestination sourceDestination ) {
 		log.info("Computing route: " + sourceDestination);
 		DatapathId rootNode = edgeSwitches.get(sourceDestination.source);
-		DatapathId destinationNode = edgeSwitches.get(sourceDestination.destination);
 		Map<DatapathId, Set<Link>> allLinks = this.topologyService.getAllLinks();
+		Map<Link, Integer> linkCost = this.linkCostCalculator.calculateLinkCost(allLinks);
 		
-		BroadcastTree broadCastTree = Dijkstra.compute(allLinks, rootNode, null, false);
+		BroadcastTree broadCastTree = Dijkstra.compute(allLinks, rootNode, linkCost, false);
 		
-		 
+		return  broadCastTree;
+	}
+	
+	private boolean installRoute(BroadcastTree broadCastTree, SourceDestination sourceDestination) {
 		Link nextLink = null;
-		DatapathId nextNode = destinationNode;
-		while ( ! nextNode.equals(rootNode) ) {
-			System.out.println(nextNode);
+		DatapathId rootNode = edgeSwitches.get(sourceDestination.source);
+		DatapathId nextNode = edgeSwitches.get(sourceDestination.destination);
+		
+		// Will hold the complete route as string at the end
+		String installedRoute = "["+nextNode+"]";
+		
+		// Tracks, if a flow as succesfully written on a switch
+		boolean success = true;
+		
+		// as long as we have not reached the rootNode, and
+		// as long as we have no write error when pushing a flow
+		while ( ! nextNode.equals(rootNode) && success == true ) {
 			nextLink = broadCastTree.getTreeLink(nextNode);
-			System.out.println(nextLink);
+			// This can be null, if the controller not has fully negotiated the roles with all switches, or the
+			// topology information was incomplete when computing dijkstra
+			if( nextLink == null) {
+				log.error("Changing topology, Controller not fully initialized?, got null link from node, aborting route installing");
+				return false;
+			}
+			//This can be null, if the controller not has fully negotiated the roles with all switches, or the
+			// topology information was incomplete when computing dijkstra
 			nextNode = nextLink.getSrc();
-			
+			if( nextNode == null) {
+				log.error("Changing topology, Controller not fully initialized?, got link to a null node, aborting route installing");
+				return false;
+			}
 			OFPort outputPort = nextLink.getSrcPort();
 			IOFSwitch switchToUpdate = this.switchService.getSwitch(nextNode);
-			updateSwitch(switchToUpdate, sourceDestination.destination, outputPort.getPortNumber(), 5 );
 			
+			success &= updateSwitch(switchToUpdate, sourceDestination.destination, outputPort.getPortNumber(), flowTimeOutInSeconds );
+			
+			installedRoute += " -- " + "["+nextNode +"]";
+		}
+		if( success ) {
+			log.info("Installed Route: " + installedRoute + " for " + sourceDestination);
+			return true;
+		} else {
+			log.info("Failed to install Route, got so far: " + installedRoute + " for " + sourceDestination);
+			return false;
 		}
-		System.out.println(nextNode);
 	}
 
 	private SourceDestination getSourceDestination(IPv4 payload) {	
diff --git a/src/main/java/net/sdnlab/ex3/Task32.java b/src/main/java/net/sdnlab/ex3/Task32.java
index 2a1b4385..e142b528 100644
--- a/src/main/java/net/sdnlab/ex3/Task32.java
+++ b/src/main/java/net/sdnlab/ex3/Task32.java
@@ -51,13 +51,14 @@ public class Task32 implements IFloodlightModule {
 		this.switchService = context.getServiceImpl(IOFSwitchService.class);
 		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
 		this.topologyService = context.getServiceImpl(ITopologyService.class);
-		this.reactiveRouting = new ReactiveRoutingModule(this.topologyService, this.switchService);
+		this.reactiveRouting = new ReactiveRoutingModule(this.topologyService, this.switchService, new Task32LinkCostCalculator() );
 	}
 
 	@Override
 	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
 		logger.info("Module Task32 loaded");
 		this.staticFlows = new Task3xStaticFlows(this.switchService);
+		this.switchService.addOFSwitchListener(this.staticFlows);
 		
 		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.reactiveRouting);
 	}
diff --git a/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java b/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java
new file mode 100644
index 00000000..550c3f67
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java
@@ -0,0 +1,32 @@
+package net.sdnlab.ex3;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+
+import net.floodlightcontroller.linkdiscovery.Link;
+
+
+/**
+ * Task 32 assumes equal link cost for every link, so we just assign 1 to every link
+ * alternative was to return null, but i personally don't like the idea of "null" values
+ * i think of that as a violation of the type system (although very convinient)
+ * @author fabian
+ *
+ */
+public class Task32LinkCostCalculator implements ILinkCostCalculator {
+	@Override
+	public Map<Link, Integer> calculateLinkCost(Map<DatapathId, Set<Link>> links) {
+		HashMap<Link, Integer> mapToPopulate = new HashMap<Link, Integer>();
+		for( DatapathId node : links.keySet() ) {
+			Set<Link> linksOfNode = links.get(node);
+			for( Link link : linksOfNode) {
+				mapToPopulate.put(link, 1);
+			}
+		}
+		//return null;
+		return mapToPopulate;
+	}
+}
diff --git a/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
index 66c139bf..5cae6ac7 100644
--- a/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
+++ b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
@@ -88,7 +88,6 @@ public class Task3xStaticFlows implements IOFSwitchListener {
 			}
 		});
 		
-		this.switchService.addOFSwitchListener(this);
 	}
 	@Override
 	public void switchAdded(DatapathId switchId) {
-- 
2.17.1


From 0daa9f307afc0ab0bf33e7de37985dd74e87ca7c Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Tue, 4 Dec 2018 17:34:59 +0100
Subject: [PATCH 16/18] [TASK33] Solution

---
 .../sdnlab/ex3/BandWithCostCalculator.java    |  67 +++++++++
 .../net/sdnlab/ex3/ILinkCostCalculator.java   |   1 +
 .../ex3/LoadBalancingRoutingModule.java       |  48 +++++++
 .../net/sdnlab/ex3/ReactiveRoutingModule.java | 132 ++++++++++++++++--
 .../sdnlab/ex3/Task32LinkCostCalculator.java  |   7 +
 src/main/java/net/sdnlab/ex3/Task33.java      |  72 ++++++++++
 ...htcontroller.core.module.IFloodlightModule |   3 +-
 src/main/resources/task33.properties          |  76 ++++++++++
 8 files changed, 390 insertions(+), 16 deletions(-)
 create mode 100644 src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
 create mode 100644 src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
 create mode 100644 src/main/java/net/sdnlab/ex3/Task33.java
 create mode 100644 src/main/resources/task33.properties

diff --git a/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java b/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
new file mode 100644
index 00000000..a0a1d71d
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
@@ -0,0 +1,67 @@
+package net.sdnlab.ex3;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.projectfloodlight.openflow.types.DatapathId;
+import org.projectfloodlight.openflow.types.U64;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.linkdiscovery.Link;
+import net.floodlightcontroller.statistics.IStatisticsService;
+import net.floodlightcontroller.statistics.SwitchPortBandwidth;
+
+public class BandWithCostCalculator implements ILinkCostCalculator {
+	private IStatisticsService statService;
+	private Logger log;
+	public BandWithCostCalculator(IStatisticsService statService) {
+		this.statService = statService;
+		this.log = LoggerFactory.getLogger(this.getClass());
+	}
+	private Map<Link, Integer> lastLinkCosts = null;
+	@Override
+	public Map<Link, Integer> calculateLinkCost(Map<DatapathId, Set<Link>> allLinks) {
+		HashMap<Link, Integer> mapToPopulate = new HashMap<Link, Integer>();
+		
+		
+		for( DatapathId node : allLinks.keySet() ) {
+			for( Link link : allLinks.get(node) ) {
+				if( node.equals(link.getSrc())) {
+					SwitchPortBandwidth spbw = statService.getBandwidthConsumption(link.getSrc(), link.getSrcPort());
+					if( spbw == null ) {
+						log.error("No statistics available, abort");
+						//actually this null is because dijkstra works with null
+						// null is a evil thing, but i am clued to the given code
+						return null;
+					}
+					// unfortunately, dijkstra where this interface comes from
+					// works with Integer, so we have suffer some pain
+					// to make sure we have reasonable values
+					U64 weight = spbw.getBitsPerSecondTx() ;
+					
+					long value =  weight.getValue();
+					int intValue = 0;
+					if ( value > (long) Integer.MAX_VALUE ) {
+						log.info("overflow, set link cost to max");
+						value = Integer.MAX_VALUE;
+					} else if( value < 0) {
+						log.info("underflow, set link cost to 0");
+						value = 0;
+					}
+					intValue  = (int) (value);
+					mapToPopulate.put(link, intValue );
+				}			
+			}
+		}
+		lastLinkCosts = mapToPopulate;
+		return mapToPopulate;
+	}
+
+	@Override
+	public Map<Link, Integer> getLastLinkCosts() {
+		return lastLinkCosts;
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java b/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
index c635ec88..1994864b 100644
--- a/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
+++ b/src/main/java/net/sdnlab/ex3/ILinkCostCalculator.java
@@ -16,4 +16,5 @@ public interface ILinkCostCalculator {
 	 */
 	Map<Link, Integer> calculateLinkCost(Map<DatapathId, Set<Link>> allLinks);
 	
+	Map<Link, Integer> getLastLinkCosts();
 }
diff --git a/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java b/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
new file mode 100644
index 00000000..4cfd0589
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
@@ -0,0 +1,48 @@
+package net.sdnlab.ex3;
+
+import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.match.Match;
+import org.projectfloodlight.openflow.protocol.match.MatchField;
+import org.projectfloodlight.openflow.types.EthType;
+import org.projectfloodlight.openflow.types.U64;
+
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.topology.ITopologyService;
+import org.projectfloodlight.openflow.protocol.match.Match.Builder;
+/**
+ * If possible do routing based on IPv4 and transportlayerinformation TCP/UDP.
+ * With a LinkCostCalculator this allows load balancing
+ * @author fabian
+ *
+ */
+public class LoadBalancingRoutingModule extends ReactiveRoutingModule {
+
+	public LoadBalancingRoutingModule(ITopologyService topologyService, IOFSwitchService switchService,
+			ILinkCostCalculator linkCostCalculator) {
+		super( topologyService, switchService, linkCostCalculator, 5, U64.of(0xAFFE),32700);
+		
+	}
+	
+	
+	// overwrite for different match
+	@Override
+	protected Match createMatch(OFFactory factoryToUse, SourceDestination sourceDestination) {
+		Builder matchBuilder = factoryToUse.buildMatch()
+					.setExact(MatchField.ETH_TYPE, EthType.IPv4)
+					.setExact(MatchField.IPV4_DST, sourceDestination.destination);
+					
+		short protocolNumber = sourceDestination.protocol.getIpProtocolNumber();
+		matchBuilder.setExact(MatchField.IP_PROTO,sourceDestination.protocol);
+		
+		if( protocolNumber  == 0x06 ) {
+			matchBuilder.setExact(MatchField.TCP_SRC, sourceDestination.sourcePort)
+			.setExact(MatchField.TCP_DST, sourceDestination.destinationPort);
+		} else if ( protocolNumber == 0x11 ) {
+			matchBuilder.setExact(MatchField.UDP_SRC, sourceDestination.sourcePort)
+			.setExact(MatchField.UDP_DST, sourceDestination.destinationPort);
+		}
+		
+		return matchBuilder.build();
+	}
+
+}
diff --git a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
index f2d8ea67..6db6b3db 100644
--- a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
+++ b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
@@ -1,5 +1,6 @@
 package net.sdnlab.ex3;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -7,14 +8,21 @@ import java.util.Map;
 import java.util.Set;
 
 import org.projectfloodlight.openflow.protocol.OFFactory;
+import org.projectfloodlight.openflow.protocol.OFFlowAdd;
 import org.projectfloodlight.openflow.protocol.OFMessage;
 import org.projectfloodlight.openflow.protocol.OFPacketOut;
 import org.projectfloodlight.openflow.protocol.OFType;
 import org.projectfloodlight.openflow.protocol.action.OFAction;
+import org.projectfloodlight.openflow.protocol.action.OFActions;
+import org.projectfloodlight.openflow.protocol.match.Match;
+import org.projectfloodlight.openflow.protocol.match.MatchField;
 import org.projectfloodlight.openflow.types.DatapathId;
 import org.projectfloodlight.openflow.types.EthType;
 import org.projectfloodlight.openflow.types.IPv4Address;
+import org.projectfloodlight.openflow.types.IpProtocol;
 import org.projectfloodlight.openflow.types.OFPort;
+import org.projectfloodlight.openflow.types.TransportPort;
+import org.projectfloodlight.openflow.types.U64;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -24,47 +32,62 @@ import net.floodlightcontroller.core.IOFMessageListener;
 import net.floodlightcontroller.core.IOFSwitch;
 import net.floodlightcontroller.core.internal.IOFSwitchService;
 import net.floodlightcontroller.linkdiscovery.Link;
-import net.floodlightcontroller.core.IListener.Command;
 import net.floodlightcontroller.packet.Ethernet;
 import net.floodlightcontroller.packet.IPv4;
+import net.floodlightcontroller.packet.TCP;
+import net.floodlightcontroller.packet.UDP;
 import net.floodlightcontroller.routing.BroadcastTree;
-import net.floodlightcontroller.topology.ITopologyListener;
 import net.floodlightcontroller.topology.ITopologyService;
 import net.sdnlab.common.dijkstra.Dijkstra;
 
 
-import static net.sdnlab.common.Helper.updateSwitch;
+
 public class ReactiveRoutingModule implements IOFMessageListener {
 
-	private Logger log;
+	protected Logger log;
 	// Store Edgeswitches associated with an IP Address in a covinient Map
 	private Map<IPv4Address, DatapathId> edgeSwitches;
 	private ITopologyService topologyService;
 	private IOFSwitchService switchService;
 	private ILinkCostCalculator linkCostCalculator;
-	private int flowTimeOutInSeconds = 5;
-	private class SourceDestination {
+	private int flowTimeOutInSeconds;
+	private U64 flowCookie;
+	private int flowPriority;
+	/**
+	 * Class for representing a end-to-end connection
+	 * actually information is aequivalent to information typically
+	 * used for socket identification
+	 * @author fabian
+	 *
+	 */
+	protected class SourceDestination {
 		// source of the packet in question
 		public IPv4Address source;
+		public TransportPort sourcePort;
 		// destination of the packet in question
 		public IPv4Address destination;
+		public TransportPort destinationPort;
+		
+		public IpProtocol protocol;
 		
 		@Override
 		public String toString() {
-			return "[Source: " + source + ", Destination: " + destination +"]";
+			return "[Source: " + source +":"+sourcePort + ", Destination: " + destination +":"+destinationPort+"]";
 		}
 	}
 	
 	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator) {
-		this ( topologyService, switchService, linkCostCalculator, 5);
+		this ( topologyService, switchService, linkCostCalculator, 5, U64.of(0xcafe),32700);
 	}
 	
-	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator, int flowTimeOutInSeconds ) {
+	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator, int flowTimeOutInSeconds, U64 flowCookie, int flowPriority ) {
 		this.topologyService = topologyService;
 		this.switchService = switchService;
 		this.linkCostCalculator = linkCostCalculator;
 		this.flowTimeOutInSeconds = flowTimeOutInSeconds;
-		log= LoggerFactory.getLogger( ReactiveRoutingModule.class );
+		this.flowCookie = flowCookie;
+		this.flowPriority = flowPriority;
+		log= LoggerFactory.getLogger( this.getClass() );
 		// Fill map of edge Switches (leaf nodes of tree)
 		edgeSwitches = new HashMap<IPv4Address, DatapathId>();
 		DatapathId switch11 = DatapathId.of("00:00:00:00:00:00:01:01");
@@ -130,7 +153,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			}
 			
 			if( routeIsInstalled && packetIsInjected ) {
-				log.info("succesflly handled " + sourceDestination );
+				log.info("successfully handled " + sourceDestination );
 			} else {
 				log.error("failed to handle " + sourceDestination + "route:" + routeIsInstalled +" packetinjectked:" + packetIsInjected);
 			}
@@ -155,6 +178,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 	private BroadcastTree computeRoute(SourceDestination sourceDestination ) {
 		log.info("Computing route: " + sourceDestination);
 		DatapathId rootNode = edgeSwitches.get(sourceDestination.source);
+		
 		Map<DatapathId, Set<Link>> allLinks = this.topologyService.getAllLinks();
 		Map<Link, Integer> linkCost = this.linkCostCalculator.calculateLinkCost(allLinks);
 		
@@ -176,14 +200,18 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		
 		// as long as we have not reached the rootNode, and
 		// as long as we have no write error when pushing a flow
+		int aggregatedLinkCost = 0;
 		while ( ! nextNode.equals(rootNode) && success == true ) {
 			nextLink = broadCastTree.getTreeLink(nextNode);
+			int linkCost = getLinkCost(nextLink);
+			aggregatedLinkCost+=linkCost;
 			// This can be null, if the controller not has fully negotiated the roles with all switches, or the
 			// topology information was incomplete when computing dijkstra
 			if( nextLink == null) {
 				log.error("Changing topology, Controller not fully initialized?, got null link from node, aborting route installing");
 				return false;
 			}
+			
 			//This can be null, if the controller not has fully negotiated the roles with all switches, or the
 			// topology information was incomplete when computing dijkstra
 			nextNode = nextLink.getSrc();
@@ -194,12 +222,14 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			OFPort outputPort = nextLink.getSrcPort();
 			IOFSwitch switchToUpdate = this.switchService.getSwitch(nextNode);
 			
-			success &= updateSwitch(switchToUpdate, sourceDestination.destination, outputPort.getPortNumber(), flowTimeOutInSeconds );
+			success &= updateSwitch(switchToUpdate, sourceDestination, outputPort );
 			
-			installedRoute += " -- " + "["+nextNode +"]";
+			installedRoute =   "["+nextNode +"]" + "--" + linkCost +"--" + installedRoute;
 		}
 		if( success ) {
-			log.info("Installed Route: " + installedRoute + " for " + sourceDestination);
+			log.info("Installed Route: {}", sourceDestination);  
+			log.info("Path: {}", installedRoute);
+			log.info("Total Route Cost:{}",  aggregatedLinkCost);
 			return true;
 		} else {
 			log.info("Failed to install Route, got so far: " + installedRoute + " for " + sourceDestination);
@@ -209,8 +239,24 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 
 	private SourceDestination getSourceDestination(IPv4 payload) {	
 			SourceDestination sourceDestination = new SourceDestination();
+			IpProtocol protocol = payload.getProtocol();
+			
 			sourceDestination.source = payload.getSourceAddress();
 			sourceDestination.destination = payload.getDestinationAddress();
+			sourceDestination.protocol = protocol;
+			
+			if( protocol.getIpProtocolNumber() == 0x06 ) {
+				TCP packet = (TCP) payload.getPayload();
+				sourceDestination.destinationPort = packet.getDestinationPort();
+				sourceDestination.sourcePort = packet.getSourcePort();	
+			} else if (protocol.getIpProtocolNumber() == 0x11 ) {
+				UDP packet = (UDP) payload.getPayload();
+				sourceDestination.destinationPort = packet.getDestinationPort();
+				sourceDestination.sourcePort = packet.getSourcePort();
+			} else {
+				log.error("Unsupported Protocol :" + protocol);
+			}
+			
 		return sourceDestination;
 	}
 	
@@ -240,5 +286,61 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		// finally write to output
 		return switchToUse.write(po);
 	}
-
+	
+	// We use some template pattern here, also the poor mans version,
+	// don't tell my colleagues ;)
+	private boolean updateSwitch(IOFSwitch switchToUpdate, SourceDestination sourceDestination, OFPort outPutPort) {	
+	 	// we want to use a factory, definitely matching to the switch
+		// so instead of using generic factory with version, we 
+		// always use the factory provided by the switch
+		OFFactory factoryToUse = switchToUpdate.getOFFactory();
+		
+		// create part of flow message
+		Match match = createMatch(factoryToUse, sourceDestination);
+		ArrayList<OFAction> actionList = createActionList(factoryToUse, sourceDestination, outPutPort);
+				
+		// create the flow message
+		OFFlowAdd flowAdd = factoryToUse.buildFlowAdd()
+				.setCookie(flowCookie)
+				.setPriority(flowPriority)
+				.setIdleTimeout(flowTimeOutInSeconds)
+				.setMatch(match)
+				.setActions(actionList)
+				.build();
+		
+		// check if it was  successfully written to the switch
+		boolean wasSuccess = switchToUpdate.write(flowAdd);
+		return wasSuccess;
+	}
+	
+	// overwrite for different match
+	protected Match createMatch(OFFactory factoryToUse, SourceDestination sourceDestination) {
+		// which packets to match
+		Match match = factoryToUse.buildMatch()
+				.setExact(MatchField.ETH_TYPE, EthType.IPv4)
+				.setExact(MatchField.IPV4_DST, sourceDestination.destination)
+				.build();
+		return match;
+	}
+	
+	// overwrite for different actions...
+	protected ArrayList<OFAction> createActionList(OFFactory factoryToUse, SourceDestination sourceDestination, OFPort outputPort) {
+		ArrayList<OFAction> actionList = new ArrayList<OFAction>();
+		OFActions actions = factoryToUse.actions();
+		actionList.add(
+				actions.buildOutput()
+				.setMaxLen(0xFFffFFff)
+				.setPort(outputPort)
+				.build());
+		return actionList;
+	}
+	
+	private int getLinkCost(Link link) {
+		Map <Link, Integer> costs = this.linkCostCalculator.getLastLinkCosts();
+		if (  costs != null ) {
+			return costs.get(link);
+		} else {
+			return 1;
+		}
+	}
 }
diff --git a/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java b/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java
index 550c3f67..d23d0a0e 100644
--- a/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java
+++ b/src/main/java/net/sdnlab/ex3/Task32LinkCostCalculator.java
@@ -17,6 +17,8 @@ import net.floodlightcontroller.linkdiscovery.Link;
  *
  */
 public class Task32LinkCostCalculator implements ILinkCostCalculator {
+	
+	private Map<Link, Integer> lastLinkcosts = null;
 	@Override
 	public Map<Link, Integer> calculateLinkCost(Map<DatapathId, Set<Link>> links) {
 		HashMap<Link, Integer> mapToPopulate = new HashMap<Link, Integer>();
@@ -27,6 +29,11 @@ public class Task32LinkCostCalculator implements ILinkCostCalculator {
 			}
 		}
 		//return null;
+		this.lastLinkcosts = mapToPopulate;
 		return mapToPopulate;
 	}
+	@Override
+	public Map<Link, Integer> getLastLinkCosts() {
+		return this.lastLinkcosts;
+	}
 }
diff --git a/src/main/java/net/sdnlab/ex3/Task33.java b/src/main/java/net/sdnlab/ex3/Task33.java
new file mode 100644
index 00000000..fc8c6821
--- /dev/null
+++ b/src/main/java/net/sdnlab/ex3/Task33.java
@@ -0,0 +1,72 @@
+package net.sdnlab.ex3;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+
+import org.projectfloodlight.openflow.protocol.OFType;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import net.floodlightcontroller.core.IFloodlightProviderService;
+import net.floodlightcontroller.core.internal.IOFSwitchService;
+import net.floodlightcontroller.core.module.FloodlightModuleContext;
+import net.floodlightcontroller.core.module.FloodlightModuleException;
+import net.floodlightcontroller.core.module.IFloodlightModule;
+import net.floodlightcontroller.core.module.IFloodlightService;
+import net.floodlightcontroller.statistics.IStatisticsService;
+import net.floodlightcontroller.topology.ITopologyService;
+
+public class Task33 implements IFloodlightModule {
+	private Logger log;
+	private IOFSwitchService switchService;
+	private IFloodlightProviderService floodlightProviderService;
+	private ITopologyService topologyService;
+	private Task3xStaticFlows staticFlows;
+	private ReactiveRoutingModule reactiveRouting;
+	private IStatisticsService statisticsService;
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
+		Collection<Class<? extends IFloodlightService>> moduleDependencies = new
+				ArrayList<Class<? extends IFloodlightService>>();
+		moduleDependencies.add(IFloodlightProviderService.class);
+		moduleDependencies.add(IOFSwitchService.class);
+		moduleDependencies.add(ITopologyService.class);
+		moduleDependencies.add(IStatisticsService.class);
+		return moduleDependencies;
+	}
+
+	@Override
+	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
+		this.log = LoggerFactory.getLogger(Task33.class);
+		log.info("Module Task33 Init");
+		this.switchService = context.getServiceImpl(IOFSwitchService.class);
+		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
+		this.topologyService = context.getServiceImpl(ITopologyService.class);
+		this.statisticsService = context.getServiceImpl(IStatisticsService.class);
+		
+		this.reactiveRouting = new LoadBalancingRoutingModule(this.topologyService, this.switchService, new BandWithCostCalculator(this.statisticsService) );
+	}
+
+	@Override
+	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		log.info("Module Task33 Startup");
+		this.staticFlows = new Task3xStaticFlows(this.switchService);
+		this.switchService.addOFSwitchListener(this.staticFlows);
+		this.statisticsService.collectStatistics(true);
+		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.reactiveRouting);
+	}
+
+}
diff --git a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
index fb43c3e2..f85f4c9f 100644
--- a/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
+++ b/src/main/resources/META-INF/services/net.floodlightcontroller.core.module.IFloodlightModule
@@ -32,4 +32,5 @@ net.floodlightcontroller.cpanalyzer.CPAnalyzer
 net.floodlightcontroller.hasupport.HAController
 net.sdnlab.ex2.Task23
 net.sdnlab.ex3.Task31
-net.sdnlab.ex3.Task32
\ No newline at end of file
+net.sdnlab.ex3.Task32
+net.sdnlab.ex3.Task33
\ No newline at end of file
diff --git a/src/main/resources/task33.properties b/src/main/resources/task33.properties
new file mode 100644
index 00000000..3c392f32
--- /dev/null
+++ b/src/main/resources/task33.properties
@@ -0,0 +1,76 @@
+floodlight.modules=\
+net.floodlightcontroller.jython.JythonDebugInterface,\
+net.floodlightcontroller.storage.memory.MemoryStorageSource,\
+net.floodlightcontroller.core.internal.FloodlightProvider,\
+net.floodlightcontroller.threadpool.ThreadPool,\
+net.floodlightcontroller.debugcounter.DebugCounterServiceImpl,\
+net.floodlightcontroller.perfmon.PktInProcessingTime,\
+net.floodlightcontroller.staticentry.StaticEntryPusher,\
+net.floodlightcontroller.restserver.RestApiServer,\
+net.floodlightcontroller.topology.TopologyManager,\
+net.floodlightcontroller.routing.RoutingManager,\
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager,\
+net.floodlightcontroller.ui.web.StaticWebRoutable,\
+net.floodlightcontroller.loadbalancer.LoadBalancer,\
+net.floodlightcontroller.firewall.Firewall,\
+net.floodlightcontroller.dhcpserver.DHCPServer,\
+net.floodlightcontroller.simpleft.FT,\
+net.floodlightcontroller.devicemanager.internal.DeviceManagerImpl,\
+net.floodlightcontroller.accesscontrollist.ACL,\
+net.floodlightcontroller.statistics.StatisticsCollector,\
+net.floodlightcontroller.hasupport.HAController, \
+net.sdnlab.ex3.Task33
+org.sdnplatform.sync.internal.SyncManager.authScheme=CHALLENGE_RESPONSE
+org.sdnplatform.sync.internal.SyncManager.keyStorePath=/etc/floodlight/myKey.jceks
+org.sdnplatform.sync.internal.SyncManager.dbPath=/var/lib/floodlight/
+org.sdnplatform.sync.internal.SyncManager.keyStorePassword=syncPass
+org.sdnplatform.sync.internal.SyncManager.port=6642
+org.sdnplatform.sync.internal.SyncManager.thisNodeId=1
+org.sdnplatform.sync.internal.SyncManager.persistenceEnabled=FALSE
+org.sdnplatform.sync.internal.SyncManager.nodes=[\
+{"nodeId": 1, "domainId": 1, "hostname": "192.168.56.1", "port": 6642},\
+{"nodeId": 2, "domainId": 1, "hostname": "192.168.56.1", "port": 6643},\
+{"nodeId": 3, "domainId": 1, "hostname": "192.168.56.1", "port": 6644},\
+{"nodeId": 4, "domainId": 1, "hostname": "192.168.56.1", "port": 6645}\
+]
+net.floodlightcontroller.forwarding.Forwarding.match=in-port, vlan, mac, ip, transport, flag
+net.floodlightcontroller.forwarding.Forwarding.detailed-match=src-mac, dst-mac, src-ip, dst-ip, src-transport, dst-transport
+net.floodlightcontroller.forwarding.Forwarding.flood-arp=NO
+net.floodlightcontroller.forwarding.Forwarding.idle-timeout=5
+net.floodlightcontroller.forwarding.Forwarding.set-send-flow-rem-flag=FALSE
+net.floodlightcontroller.forwarding.Forwarding.remove-flows-on-link-or-port-down=TRUE
+net.floodlightcontroller.core.internal.FloodlightProvider.openFlowPort=6653
+net.floodlightcontroller.core.internal.FloodlightProvider.role=ACTIVE
+net.floodlightcontroller.core.internal.FloodlightProvider.controllerId=1
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-history-size=10
+net.floodlightcontroller.linkdiscovery.internal.LinkDiscoveryManager.latency-update-threshold=0.5
+net.floodlightcontroller.core.internal.FloodlightProvider.shutdownOnTransitionToStandby=true
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowPort=6653
+net.floodlightcontroller.core.internal.OFSwitchManager.openFlowAddresses=0.0.0.0
+net.floodlightcontroller.core.internal.OFSwitchManager.workerThreads=16
+net.floodlightcontroller.core.internal.OFSwitchManager.bossThreads=1
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionBacklog=1000
+net.floodlightcontroller.core.internal.OFSwitchManager.connectionTimeoutMs=60000
+net.floodlightcontroller.core.internal.OFSwitchManager.defaultMaxTablesToReceiveTableMissFlow=1
+net.floodlightcontroller.core.internal.OFSwitchManager.maxTablesToReceiveTableMissFlowPerDpid={"00:00:00:00:00:00:00:01":"1","2":"1"}
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnInitialHandshakeAsMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.clearTablesOnEachTransitionToMaster=YES
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePath=/path/to.jecks
+net.floodlightcontroller.core.internal.OFSwitchManager.keyStorePassword=PassFL
+net.floodlightcontroller.core.internal.OFSwitchManager.useSsl=NO
+net.floodlightcontroller.core.internal.OFSwitchManager.supportedOpenFlowVersions=1.0, 1.1, 1.2, 1.3, 1.4, 1.5
+net.floodlightcontroller.core.internal.OFSwitchManager.switchesInitialState={"00:00:00:00:00:00:00:01":"ROLE_MASTER","00:00:00:00:00:00:00:02":"ROLE_MASTER", "00:00:00:00:00:00:00:03":"ROLE_MASTER", "00:00:00:00:00:00:00:04":"ROLE_MASTER","00:00:00:00:00:00:00:05":"ROLE_MASTER","00:00:00:00:00:00:00:06":"ROLE_MASTER","00:00:00:00:00:00:00:07":"ROLE_MASTER","00:00:00:00:00:00:00:08":"ROLE_MASTER"}
+net.floodlightcontroller.restserver.RestApiServer.keyStorePath=/path/to.jceks
+net.floodlightcontroller.restserver.RestApiServer.keyStorePassword=Password
+net.floodlightcontroller.restserver.RestApiServer.httpsNeedClientAuthentication=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttps=NO
+net.floodlightcontroller.restserver.RestApiServer.useHttp=YES
+net.floodlightcontroller.restserver.RestApiServer.httpsPort=8081
+net.floodlightcontroller.restserver.RestApiServer.httpPort=8080
+net.floodlightcontroller.restserver.RestApiServer.accessControlAllowAllOrigins=TRUE
+net.floodlightcontroller.statistics.StatisticsCollector.enable=FALSE
+net.floodlightcontroller.statistics.StatisticsCollector.collectionIntervalPortStatsSeconds=2
+net.floodlightcontroller.topology.TopologyManager.pathMetric=latency
+net.floodlightcontroller.topology.TopologyManager.maxPathsToCompute=3
+net.floodlightcontroller.hasupport.HAController.nodeid=1
+net.floodlightcontroller.hasupport.HAController.serverPort=127.0.0.1:4242
-- 
2.17.1


From 115e725552032f7d9556f2bfd9c509957547ef48 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Tue, 4 Dec 2018 21:43:57 +0100
Subject: [PATCH 17/18] [TASK33] Some minor improvments

+duplicate detection
---
 .../sdnlab/ex3/BandWithCostCalculator.java    |   6 +-
 .../ex3/LoadBalancingRoutingModule.java       |   2 +-
 .../net/sdnlab/ex3/ReactiveRoutingModule.java | 108 ++++++++++++++++--
 3 files changed, 103 insertions(+), 13 deletions(-)

diff --git a/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java b/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
index a0a1d71d..104ee4c7 100644
--- a/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
+++ b/src/main/java/net/sdnlab/ex3/BandWithCostCalculator.java
@@ -46,9 +46,9 @@ public class BandWithCostCalculator implements ILinkCostCalculator {
 					if ( value > (long) Integer.MAX_VALUE ) {
 						log.info("overflow, set link cost to max");
 						value = Integer.MAX_VALUE;
-					} else if( value < 0) {
-						log.info("underflow, set link cost to 0");
-						value = 0;
+					} else if( value < 1) {
+						log.debug("underflow, set link cost to 1, do not tolerate values below 1");
+						value = 1;
 					}
 					intValue  = (int) (value);
 					mapToPopulate.put(link, intValue );
diff --git a/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java b/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
index 4cfd0589..cad795ca 100644
--- a/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
+++ b/src/main/java/net/sdnlab/ex3/LoadBalancingRoutingModule.java
@@ -19,7 +19,7 @@ public class LoadBalancingRoutingModule extends ReactiveRoutingModule {
 
 	public LoadBalancingRoutingModule(ITopologyService topologyService, IOFSwitchService switchService,
 			ILinkCostCalculator linkCostCalculator) {
-		super( topologyService, switchService, linkCostCalculator, 5, U64.of(0xAFFE),32700);
+		super( topologyService, switchService, linkCostCalculator, 60, U64.of(0xAFFE),32700);
 		
 	}
 	
diff --git a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
index 6db6b3db..626e67d9 100644
--- a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
+++ b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
@@ -1,6 +1,7 @@
 package net.sdnlab.ex3;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -21,6 +22,7 @@ import org.projectfloodlight.openflow.types.EthType;
 import org.projectfloodlight.openflow.types.IPv4Address;
 import org.projectfloodlight.openflow.types.IpProtocol;
 import org.projectfloodlight.openflow.types.OFPort;
+import org.projectfloodlight.openflow.types.TableId;
 import org.projectfloodlight.openflow.types.TransportPort;
 import org.projectfloodlight.openflow.types.U64;
 import org.slf4j.Logger;
@@ -30,6 +32,7 @@ import net.floodlightcontroller.core.FloodlightContext;
 import net.floodlightcontroller.core.IFloodlightProviderService;
 import net.floodlightcontroller.core.IOFMessageListener;
 import net.floodlightcontroller.core.IOFSwitch;
+import net.floodlightcontroller.core.IListener.Command;
 import net.floodlightcontroller.core.internal.IOFSwitchService;
 import net.floodlightcontroller.linkdiscovery.Link;
 import net.floodlightcontroller.packet.Ethernet;
@@ -51,8 +54,11 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 	private IOFSwitchService switchService;
 	private ILinkCostCalculator linkCostCalculator;
 	private int flowTimeOutInSeconds;
+	private long flowTimeOutInMillis;
 	private U64 flowCookie;
 	private int flowPriority;
+	private long flowCounter = 0;
+	private HashMap<SourceDestination, Long> lastSeenFlow;
 	/**
 	 * Class for representing a end-to-end connection
 	 * actually information is aequivalent to information typically
@@ -70,10 +76,69 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		
 		public IpProtocol protocol;
 		
+		
+		
 		@Override
 		public String toString() {
 			return "[Source: " + source +":"+sourcePort + ", Destination: " + destination +":"+destinationPort+"]";
 		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + getOuterType().hashCode();
+			result = prime * result + ((destination == null) ? 0 : destination.hashCode());
+			result = prime * result + ((destinationPort == null) ? 0 : destinationPort.hashCode());
+			result = prime * result + ((protocol == null) ? 0 : protocol.hashCode());
+			result = prime * result + ((source == null) ? 0 : source.hashCode());
+			result = prime * result + ((sourcePort == null) ? 0 : sourcePort.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			SourceDestination other = (SourceDestination) obj;
+			if (!getOuterType().equals(other.getOuterType()))
+				return false;
+			if (destination == null) {
+				if (other.destination != null)
+					return false;
+			} else if (!destination.equals(other.destination))
+				return false;
+			if (destinationPort == null) {
+				if (other.destinationPort != null)
+					return false;
+			} else if (!destinationPort.equals(other.destinationPort))
+				return false;
+			if (protocol == null) {
+				if (other.protocol != null)
+					return false;
+			} else if (!protocol.equals(other.protocol))
+				return false;
+			if (source == null) {
+				if (other.source != null)
+					return false;
+			} else if (!source.equals(other.source))
+				return false;
+			if (sourcePort == null) {
+				if (other.sourcePort != null)
+					return false;
+			} else if (!sourcePort.equals(other.sourcePort))
+				return false;
+			return true;
+		}
+
+		private ReactiveRoutingModule getOuterType() {
+			return ReactiveRoutingModule.this;
+		}
+		
 	}
 	
 	public ReactiveRoutingModule(ITopologyService topologyService, IOFSwitchService switchService, ILinkCostCalculator linkCostCalculator) {
@@ -85,8 +150,10 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		this.switchService = switchService;
 		this.linkCostCalculator = linkCostCalculator;
 		this.flowTimeOutInSeconds = flowTimeOutInSeconds;
+		this.flowTimeOutInMillis = flowTimeOutInSeconds * 1000;
 		this.flowCookie = flowCookie;
 		this.flowPriority = flowPriority;
+		this.lastSeenFlow = new HashMap<SourceDestination, Long>();
 		log= LoggerFactory.getLogger( this.getClass() );
 		// Fill map of edge Switches (leaf nodes of tree)
 		edgeSwitches = new HashMap<IPv4Address, DatapathId>();
@@ -133,8 +200,8 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 	public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
 		// check if we have a packet of the right type	
 		Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);
- 
-		if( eth.getEtherType().equals(EthType.IPv4)) {	
+	
+		if( eth.getEtherType().equals(EthType.IPv4)) {
 			IPv4 payload = (IPv4) eth.getPayload();
 			SourceDestination sourceDestination = getSourceDestination(payload);
 			
@@ -142,28 +209,50 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 				// Maybe someone else is interrested....
 				return Command.CONTINUE;
 			}
+			if( checkIfFlowAlreadyInstalled(sourceDestination)) {
+				// flow is installed, but we have some packet in
+				// because of a fast sending process
+				injectPacketForHost(sourceDestination.destination, eth);
+				return Command.CONTINUE;
+			}
 			
 			BroadcastTree route = computeRoute(sourceDestination);
 			
 			boolean routeIsInstalled = installRoute(route, sourceDestination);
 			boolean packetIsInjected = false;
-			
+			Collection<TableId> tables = sw.getTables();
+	
 			if(routeIsInstalled) {
 				packetIsInjected = injectPacketForHost(sourceDestination.destination, eth);
 			}
 			
 			if( routeIsInstalled && packetIsInjected ) {
-				log.info("successfully handled " + sourceDestination );
+				log.info("#{} successfully handled {}",  ++flowCounter, sourceDestination );
+				lastSeenFlow.put(sourceDestination, System.currentTimeMillis() );
 			} else {
 				log.error("failed to handle " + sourceDestination + "route:" + routeIsInstalled +" packetinjectked:" + packetIsInjected);
 			}
-			
-			return Command.STOP;
-		} else {
-			return Command.CONTINUE;
-		}	
+		}
+		return Command.CONTINUE;
+	}
+	// sometimes when a process sends a lot of packets, like iperf
+	// we receive more than on packet on packet in before we have installed the flow
+	// this is to handle this
+	private boolean checkIfFlowAlreadyInstalled(SourceDestination sourceDestination) {
+		if( lastSeenFlow.containsKey(sourceDestination) ) {			
+			long currentTime = System.currentTimeMillis();
+			long lastSeenTime = lastSeenFlow.get(sourceDestination);
+			long diff = currentTime - lastSeenTime;
+			if( diff < (flowTimeOutInMillis / 2 )  ) {
+				return true;
+			}
+		
+		}
+		return false;
 	}
 	
+	 
+	
 	// we only want to compute routes for edge links we know
 	private boolean checkIfValid(SourceDestination sourceDestination ) {
 		if (edgeSwitches.containsKey(sourceDestination.destination)  
@@ -262,6 +351,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 	
 	private boolean injectPacketForHost(IPv4Address hostAddr, Ethernet packet) {
 		// First find out on which switch and port to inject
+		log.info("Injecting Packet to {} ", hostAddr);
 		DatapathId id  = edgeSwitches.get(hostAddr );
 		if( id == null) {
 			log.info("Could not find a switch for host" + hostAddr);
-- 
2.17.1


From 0f019158ec593d1ce22f5feba1e6dfa7c9006987 Mon Sep 17 00:00:00 2001
From: FP-Guitar <fabian@pfeifroth.de>
Date: Mon, 10 Dec 2018 12:02:33 +0100
Subject: [PATCH 18/18] [CLEANUP] Some cleanup, some comments additionally
 logging

---
 src/main/java/net/sdnlab/ex3/ARPCache.java    | 22 ++++++++---
 src/main/java/net/sdnlab/ex3/ARPHandler.java  | 13 ++++---
 .../net/sdnlab/ex3/ReactiveRoutingModule.java | 38 ++++++++++++-------
 src/main/java/net/sdnlab/ex3/Task31.java      | 19 ++++++----
 src/main/java/net/sdnlab/ex3/Task33.java      | 10 ++++-
 .../net/sdnlab/ex3/Task3xStaticFlows.java     |  5 ++-
 6 files changed, 71 insertions(+), 36 deletions(-)

diff --git a/src/main/java/net/sdnlab/ex3/ARPCache.java b/src/main/java/net/sdnlab/ex3/ARPCache.java
index 3619e09a..4c58f8ed 100644
--- a/src/main/java/net/sdnlab/ex3/ARPCache.java
+++ b/src/main/java/net/sdnlab/ex3/ARPCache.java
@@ -10,15 +10,16 @@ import org.slf4j.LoggerFactory;
 import net.sdnlab.ex3.ARPEntry;
 public class ARPCache {
 		private static Logger logger;
+		private boolean printAlwaysFullCache = true;
 		public ARPCache() {
 			logger = LoggerFactory.getLogger(ARPCache.class.getName());
 		}
 		// Use Map instead of Arrays of entries for faster search
 		private static Map<IPv4Address, MacAddress> arpEntries = new HashMap<IPv4Address,MacAddress>();
 		/**
-		 * Get an 
+		 * Get an ArpEntry to a given IPAddress
 		 * @param ipAddress
-		 * @return
+		 * @return ARPEntry
 		 */
 		public synchronized ARPEntry getEntryFromIP( IPv4Address ipAddress ) {
 			MacAddress match = arpEntries.get(ipAddress);
@@ -44,8 +45,9 @@ public class ARPCache {
 		 * @param entry To store
 		 */
 		public synchronized void storeEntry( ARPEntry entry ) {
-			logger.info("Stored " + entry);
+			logger.info("Storing " + entry);
 			arpEntries.put(entry.getIpAddress(), entry.getMacAddress());
+			printCache();
 		}
 		
 		/**
@@ -55,15 +57,25 @@ public class ARPCache {
 		 */
 		public synchronized void deleteEntryByIp( IPv4Address ipAddress ) {		
 			if ( arpEntries.containsKey(ipAddress) ) {
-				logger.info("Delete " + arpEntries.get(ipAddress));
+				logger.info("Deleting " + arpEntries.get(ipAddress));
 				arpEntries.remove(ipAddress);
-				
+				printCache();
 			}
 		}
 		
 		public synchronized void reset() {
 			logger.info("Reset cache (clear)");
 			arpEntries.clear();
+			printCache();
+		}
+		
+		void printCache( ) {
+			if ( printAlwaysFullCache ) {
+				logger.info("Printing all Entries:");
+				for ( IPv4Address addr : arpEntries.keySet() ) {
+					logger.info( ARPEntry.of( addr, arpEntries.get(addr) ).toString() );
+				}
+			}
 		}
 		
 		
diff --git a/src/main/java/net/sdnlab/ex3/ARPHandler.java b/src/main/java/net/sdnlab/ex3/ARPHandler.java
index 89261375..29668140 100644
--- a/src/main/java/net/sdnlab/ex3/ARPHandler.java
+++ b/src/main/java/net/sdnlab/ex3/ARPHandler.java
@@ -117,23 +117,24 @@ public class ARPHandler implements IOFMessageListener {
 	public Command receive(IOFSwitch sw, OFMessage msg, FloodlightContext cntx) {
 		Ethernet eth = IFloodlightProviderService.bcStore.get(cntx, IFloodlightProviderService.CONTEXT_PI_PAYLOAD);
 		// check if we have a packet of the right type
-		if( eth.getEtherType().equals(EthType.ARP)) {				
+		if( eth.getEtherType().equals(EthType.ARP) ) {				
 			ARP payload = (ARP) eth.getPayload();
 			ArpOpcode opcode  = payload.getOpCode();
+			
 			if( opcode == ArpOpcode.REQUEST ) {
-				handleARPRequest(sw, msg, cntx, payload );
+				handleARPRequest( payload );
 			} else if ( opcode == ArpOpcode.REPLY ) {
-				handleARPReply(sw, msg, cntx, payload );
+				handleARPReply( payload );
 			} else {
 				logger.info("Unhandeld ARPOpcode of type " + opcode.toString() );
 			}
-			// no one else should handle arp requests
+			// no one else should handle arp messages
 			return Command.STOP;
 		}
 		return Command.CONTINUE;
 	}
 	
-	private void handleARPRequest(IOFSwitch sw, OFMessage msg, FloodlightContext cntx, ARP payload ) {
+	private void handleARPRequest( ARP payload ) {
 		logger.info("Handling ARPRequest from " +  payload.getSenderProtocolAddress() );
 
 		ARPEntry requestSender = ARPEntry.of(payload.getSenderProtocolAddress(), payload.getSenderHardwareAddress());
@@ -220,7 +221,7 @@ public class ARPHandler implements IOFMessageListener {
 		return switchToUse.write(po);
 	}
 	
-	private void handleARPReply(IOFSwitch sw, OFMessage msg, FloodlightContext cnt, ARP payload  ) {
+	private void handleARPReply( ARP payload  ) {
 		if( ! arpCache.contains(payload.getSenderProtocolAddress() )) {
 			arpCache.storeEntry( ARPEntry.of(payload.getSenderProtocolAddress(), payload.getSenderHardwareAddress()));
 		} 
diff --git a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
index 626e67d9..97042ac3 100644
--- a/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
+++ b/src/main/java/net/sdnlab/ex3/ReactiveRoutingModule.java
@@ -75,12 +75,14 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		public TransportPort destinationPort;
 		
 		public IpProtocol protocol;
-		
-		
-		
+			
 		@Override
 		public String toString() {
-			return "[Source: " + source +":"+sourcePort + ", Destination: " + destination +":"+destinationPort+"]";
+			String strSourcePort = "noPort";
+			String strDestinationPort ="noPort";
+			strSourcePort = sourcePort == null ? "noPort" : sourcePort.toString();
+			strDestinationPort = destinationPort == null ? "noPort" : destinationPort.toString();
+			return "[Source: " + source +":"+strSourcePort + ", Destination: " + destination +":"+strDestinationPort+"]";
 		}
 
 		@Override
@@ -205,11 +207,11 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			IPv4 payload = (IPv4) eth.getPayload();
 			SourceDestination sourceDestination = getSourceDestination(payload);
 			
-			if( ! checkIfValid( sourceDestination )) {
+			if( ! checkIfValid( sourceDestination ) ) {
 				// Maybe someone else is interrested....
 				return Command.CONTINUE;
 			}
-			if( checkIfFlowAlreadyInstalled(sourceDestination)) {
+			if( checkIfFlowAlreadyInstalled(sourceDestination) ) {
 				// flow is installed, but we have some packet in
 				// because of a fast sending process
 				injectPacketForHost(sourceDestination.destination, eth);
@@ -222,7 +224,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			boolean packetIsInjected = false;
 			Collection<TableId> tables = sw.getTables();
 	
-			if(routeIsInstalled) {
+			if( routeIsInstalled ) {
 				packetIsInjected = injectPacketForHost(sourceDestination.destination, eth);
 			}
 			
@@ -230,7 +232,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 				log.info("#{} successfully handled {}",  ++flowCounter, sourceDestination );
 				lastSeenFlow.put(sourceDestination, System.currentTimeMillis() );
 			} else {
-				log.error("failed to handle " + sourceDestination + "route:" + routeIsInstalled +" packetinjectked:" + packetIsInjected);
+				log.error("failed to handle " + sourceDestination + "route:" + routeIsInstalled +" packetinjected:" + packetIsInjected);
 			}
 		}
 		return Command.CONTINUE;
@@ -243,6 +245,8 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			long currentTime = System.currentTimeMillis();
 			long lastSeenTime = lastSeenFlow.get(sourceDestination);
 			long diff = currentTime - lastSeenTime;
+			// The half of the flow timeout seems to be a reasonable
+			// timeout... 
 			if( diff < (flowTimeOutInMillis / 2 )  ) {
 				return true;
 			}
@@ -263,7 +267,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			return false;
 		}
 	}
-	
+	// use dijkstra implementation from floodlight...
 	private BroadcastTree computeRoute(SourceDestination sourceDestination ) {
 		log.info("Computing route: " + sourceDestination);
 		DatapathId rootNode = edgeSwitches.get(sourceDestination.source);
@@ -289,6 +293,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 		
 		// as long as we have not reached the rootNode, and
 		// as long as we have no write error when pushing a flow
+		// we install the flow backwards.. from destination to source...
 		int aggregatedLinkCost = 0;
 		while ( ! nextNode.equals(rootNode) && success == true ) {
 			nextLink = broadCastTree.getTreeLink(nextNode);
@@ -301,7 +306,7 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 				return false;
 			}
 			
-			//This can be null, if the controller not has fully negotiated the roles with all switches, or the
+			// This can be null, if the controller not has fully negotiated the roles with all switches, or the
 			// topology information was incomplete when computing dijkstra
 			nextNode = nextLink.getSrc();
 			if( nextNode == null) {
@@ -312,12 +317,12 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			IOFSwitch switchToUpdate = this.switchService.getSwitch(nextNode);
 			
 			success &= updateSwitch(switchToUpdate, sourceDestination, outputPort );
-			
-			installedRoute =   "["+nextNode +"]" + "--" + linkCost +"--" + installedRoute;
+			// collect the route information for debug output
+			installedRoute =   "["+nextNode +"]\n" + "--" + linkCost +"--" + installedRoute;
 		}
 		if( success ) {
 			log.info("Installed Route: {}", sourceDestination);  
-			log.info("Path: {}", installedRoute);
+			log.info("Path: \n{}", installedRoute);
 			log.info("Total Route Cost:{}",  aggregatedLinkCost);
 			return true;
 		} else {
@@ -325,7 +330,12 @@ public class ReactiveRoutingModule implements IOFMessageListener {
 			return false;
 		}
 	}
-
+	/**
+	 * potentially unsafe, no handling of corrupted network traffic
+	 * e.g. iperf3 udp packets seem to be not deseriliazable...
+	 * @param payload
+	 * @return SourceDestination for a given IPv4 payload...
+	 */
 	private SourceDestination getSourceDestination(IPv4 payload) {	
 			SourceDestination sourceDestination = new SourceDestination();
 			IpProtocol protocol = payload.getProtocol();
diff --git a/src/main/java/net/sdnlab/ex3/Task31.java b/src/main/java/net/sdnlab/ex3/Task31.java
index 2ca3f6ed..ecc7c538 100644
--- a/src/main/java/net/sdnlab/ex3/Task31.java
+++ b/src/main/java/net/sdnlab/ex3/Task31.java
@@ -65,6 +65,18 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 		this.floodlightProviderService = context.getServiceImpl(IFloodlightProviderService.class);
 		this.topologyService = context.getServiceImpl(ITopologyService.class);
 		
+
+	}
+
+	@Override
+	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
+		// create the arp handler and add the messageListener
+		this.arpHandler = new ARPHandler( this.switchService );
+		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.arpHandler);
+		
+		// add messagelistener to switch for installing routes...
+		this.switchService.addOFSwitchListener(this);
+		
 		this.topologyService.addListener( new ITopologyListener() {
 			// We need to reset the cache, if something has changed
 			@Override
@@ -73,13 +85,6 @@ public class Task31 implements IFloodlightModule, IOFSwitchListener {
 				arpHandler.resetCache();
 			}
 		});
-		this.arpHandler = new ARPHandler( this.switchService );
-	}
-
-	@Override
-	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
-		this.switchService.addOFSwitchListener(this);
-		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.arpHandler);
 	}
 
 	@Override
diff --git a/src/main/java/net/sdnlab/ex3/Task33.java b/src/main/java/net/sdnlab/ex3/Task33.java
index fc8c6821..d5f5134c 100644
--- a/src/main/java/net/sdnlab/ex3/Task33.java
+++ b/src/main/java/net/sdnlab/ex3/Task33.java
@@ -57,15 +57,21 @@ public class Task33 implements IFloodlightModule {
 		this.topologyService = context.getServiceImpl(ITopologyService.class);
 		this.statisticsService = context.getServiceImpl(IStatisticsService.class);
 		
-		this.reactiveRouting = new LoadBalancingRoutingModule(this.topologyService, this.switchService, new BandWithCostCalculator(this.statisticsService) );
+		
 	}
 
 	@Override
 	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
 		log.info("Module Task33 Startup");
+		// start statistics collection
+		this.statisticsService.collectStatistics(true);
+		// add module for static flows
 		this.staticFlows = new Task3xStaticFlows(this.switchService);
 		this.switchService.addOFSwitchListener(this.staticFlows);
-		this.statisticsService.collectStatistics(true);
+		
+		// add module for reactive Routing:
+		ILinkCostCalculator linkCostCalculator = new BandWithCostCalculator(this.statisticsService);
+		this.reactiveRouting = new LoadBalancingRoutingModule(this.topologyService, this.switchService, linkCostCalculator );
 		this.floodlightProviderService.addOFMessageListener(OFType.PACKET_IN, this.reactiveRouting);
 	}
 
diff --git a/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
index 5cae6ac7..8edfa5aa 100644
--- a/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
+++ b/src/main/java/net/sdnlab/ex3/Task3xStaticFlows.java
@@ -106,8 +106,9 @@ public class Task3xStaticFlows implements IOFSwitchListener {
 			logger.info("Pushing static flow to: " + switchId );
 			IOFSwitch switchToUse = switchService.getSwitch(switchId);
 			boolean success = staticFlows.get(switchId).update(switchToUse);
-			logger.info("Success: " + success);
-			
+			logger.info("Success: " + success);		
+		} else {
+			logger.info("No Flow for {}" , switchId );
 		}
 
 	}
-- 
2.17.1

